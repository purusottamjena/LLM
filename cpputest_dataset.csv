Section,Content
Getting started,"Test Macros
Assertions
Setup and Teardown
Command Line Switches
Memory Leak Detection
Test Plugins
Scripts
Advanced Stuff
C Interface
Using Google Mock
Running Google Tests in CppUTest
Getting Started
Your first test
To write your first test, all you need is a new cpp file with a TEST_GROUP and a TEST, like:
#include ""CppUTest/TestHarness.h""
TEST_GROUP
(
FirstTestGroup
)
{
};
TEST
(
FirstTestGroup
,
FirstTest
)
{
FAIL
(
""Fail me!""
);
}
This test will fail. For adding new test_groups, this will be all you need to do (and make sure its compiled). If you want to add another test, all you need to do it:
TEST
(
FirstTestGroup
,
SecondTest
)
{
STRCMP_EQUAL
(
""hello""
,
""world""
);
}
One of the key design goals in CppUTest is to make it
very easy
to add and remove tests as this is something you’ll be doing a lot when test-driving your code.
Writing your main
Of course, in order to get it to run, you’ll need to create a main. Most of the mains in CppUTest are very similar. They typically are in an AllTests.cpp file and look like this:
#include ""CppUTest/CommandLineTestRunner.h""
int
main
(
int
ac
,
char
**
av
)
{
return
CommandLineTestRunner
::
RunAllTests
(
ac
,
av
);
}
CppUTest will automatically find your tests (as long as you don’t link them in a library).
Makefile changes
To get the above to work, you’ll need a Makefile or change your existing one. The needed changed are:
CppUTest path
If you have a system installed version (e.g. via apt-get) then you probably don’t need to change the path. Otherwise you’ll need to add CppUTest include directories to your Makefile. Usually this is done by definining a CppUTest path either as system variable or in the Makefile, such as:
CPPUTEST_HOME
=
/Users/vodde/workspace/cpputest
Compiler options
For the compiler you have to add the include path and optional (but recommended) the CppUTest pre-include header which enables debug information for the memory leak detector
and
offers memory leak detection in C. Lets start with the include path, you’ll need to add:
CPPFLAGS
+=
-I
$(CPPUTEST_HOME)
/include
(CPPFLAGS works for both .c and .cpp files!)
Then for the memory leak detection, you’ll need to add:
CXXFLAGS
+=
-include
$(CPPUTEST_HOME)
/include/CppUTest/MemoryLeakDetectorNewMacros.h
CFLAGS
+=
-include
$(CPPUTEST_HOME)
/include/CppUTest/MemoryLeakDetectorMallocMacros.h
These flags need to be added to
both
test code
and
production code. They will replace the malloc and new with a debug variant.
Linker options
You need to add CppUTest library to the linker flags, for example, like:
LD_LIBRARIES
=
-L
$(CPPUTEST_HOME)
/lib
-lCppUTest
-lCppUTestExt
(The last flag is only needed when you want to use extensions such as mocking)
Most commonly used Test Macros
TEST(group, name) - define a test
IGNORE_TEST(group, name) - turn off the execution of a test
TEST_GROUP(group) - Declare a test group to which certain tests belong.
This will also create the link needed from another library.
TEST_GROUP_BASE(group, base) - Same as TEST_GROUP, just use a different base class than Utest
IMPORT_TEST_GROUP(group) - Export the name of a test group so it can be linked in from a library (also see Advanced Stuff)
Set up and tear down support
Each TEST_GROUP may contain setup or teardown methods
Setup is called prior to each TEST body and Teardown is called after the test body
Assertions
The failure of one of these macros causes the current test to immediately exit:
CHECK(boolean condition) - checks any boolean result.
CHECK_TEXT(boolean condition, text) - checks any boolean result and prints text on failure.
CHECK_FALSE(condition) - checks any boolean result
CHECK_EQUAL(expected, actual) - checks for equality between entities using ==. So if you have a class that supports operator==() you can use this macro to compare two instances.  You will also need to add a StringFrom() function like those found in SimpleString. This is for printing the objects when the check failed.
CHECK_COMPARE(first, relop, second) - checks thats a relational operator holds between two entities. On failure, prints what both operands evaluate to.
CHECK_THROWS(expected_exception, expression) - checks if expression throws expected_exception (e.g. std::exception). CHECK_THROWS is only available if CppUTest is built with the Standard C++ Library (default).
STRCMP_EQUAL(expected, actual) - checks const char* strings for equality using strcmp().
STRNCMP_EQUAL(expected, actual, length) - checks const char* strings for equality using strncmp().
STRCMP_NOCASE_EQUAL(expected, actual) - checks const char* strings for equality, not considering case.
STRCMP_CONTAINS(expected, actual) - checks whether const char* actual contains const char* expected.
LONGS_EQUAL(expected, actual) - compares two numbers.
UNSIGNED_LONGS_EQUAL(expected, actual) - compares two positive numbers.
BYTES_EQUAL(expected, actual) - compares two numbers, eight bits wide.
POINTERS_EQUAL(expected, actual) - compares two pointers.
DOUBLES_EQUAL(expected, actual, tolerance) - compares two floating point numbers within some tolerance
FUNCTIONPOINTERS_EQUAL(expected, actual) - compares two void (*)() function pointers
MEMCMP_EQUAL(expected, actual, size) - compares two areas of memory
BITS_EQUAL(expected, actual, mask) - compares expected to actual bit by bit, applying mask
FAIL(text) - always fails
NOTE
Most macros have _TEXT() equivalents like CHECK_TEXT(), which are not explicitly listed here.
CHECK_EQUAL Warning:
CHECK_EQUAL(expected, actual) can produce misleading error reports as it will evaluate expected and actual more than once. This especially leads to confusions when used with mocks. This happens if the mock function expects to be called exactly once, since the macro needs to evaluate the actual expression more than once. The problem does not occur with type specific checks (e.g. LONGS_EQUAL()), so it is recommended to use them if possible. Instead of:
CHECK_EQUAL
(
10
,
mock_returning_11
())
which reports: Mock Failure: Unexpected additional call, rather use
LONGS_EQUAL
(
10
,
mock_returning_11
())
// reports actual different from expected
This issue could only be avoided with advanced language features like C++ templates, which would violate the CppUTest design goal portability to old environments.
Setup and Teardown
Every test group can have a setup and a teardown method. The setup method is called
before
each test and the teardown method is called
after
each test.
You can define setup and teardown like this:
TEST_GROUP
(
FooTestGroup
)
{
void
setup
()
{
// Init stuff
}
void
teardown
()
{
// Un-init stuff
}
};
TEST
(
FooTestGroup
,
Foo
)
{
// Test FOO
}
TEST
(
FooTestGroup
,
MoreFoo
)
{
// Test more FOO
}
TEST_GROUP
(
BarTestGroup
)
{
void
setup
()
{
// Init Bar
}
};
TEST
(
BarTestGroup
,
Bar
)
{
// Test Bar
}
The test execution of this will
likely
(no guarantee of order in CppUTest) be:
setup BarTestGroup
Bar
setup FooTestGroup
MoreFoo
teardown FooTestGroup
setup FooTestGroup
Foo
teardown FooTestGroup
Command line Switches
-c
colorize output, print green if OK, or red if failed
-g group
only run test whose group contains the substring
group
-k
package name, Add a package name in JUnit output (for classification in CI systems)
-lg
print a list of group names, separated by spaces
-ln
print a list of test names in the form of
group.name
, separated by spaces
-n name
only run test whose name contains the substring
name
-ojunit
output to JUnit ant plugin style xml files (for CI systems)
-oteamcity
output to xml files (as the name suggests, for TeamCity)
-p
run tests in a separate process.
-r#
repeat the tests some number (#) of times, or twice if # is not specified. This is handy if you are experiencing memory leaks. A second run that has no leaks indicates that someone is allocating statics and not releasing them.
-sg group
only run test whose group exactly matches the string
group
-sn name
only run test whose name exactly matches the string
name
-v
verbose, print each test name as it runs
-xg group
exclude tests whose group contains the substring
group
(v3.8)
-xn name
exclude tests whose name contains the substring
name
(v3.8)
“TEST(group, name)”
only run test whose group and name matches the strings group and name. This can be used to copy-paste output from the -v option on the command line.
You can specify multiple -s|sg, -s|sn and “TEST(group, name)” parameters:
Specifying only test groups with multiple -s|sg parameters will run all tests in those groups, since no test name matches all test names.
Specifying only test names with multiple -s|sn parameters will run all tests whose names match, since no test group matches all test groups.
Mixing multiple -s|sg and -s|sn parameters (or using “TEST(group, name)” will only run tests whose groups match as well as their names.
Combining one -xg parameter with one -xn parameter will run only those tests that satisfy both criteria.
Combining -s|sg with -xn, or -s|sn with -xg will run only those tests that satisfy both criteria.
Specifying several -xg or -xn with each other or in other combinations has no effect.
NOTE
Be careful with
-p
:
Some systems do not support this feature, in which case tests will fail
with a suitable message.
Using
-p
to run tests in a separate process can have unexpected side
effects.
While running tests in a separate process can help to get more information
about an unexpected crash, when an expected crash is part of the test scenario,
the
-p
command line option should not be used, but running in a separate
process should be enabled on a per-test basis like this:
TestRegistry
::
getCurrentRegistry
()
->
setRunTestsInSeperateProcess
();
Examples for this can be found in CppUTests’s own tests.
Memory Leak Detection
CppUTest has memory leak detection support on a per-test level. This means that it automatically checks whether the memory at the end of a test is the same as at the beginning of the test.
Explained another way:
Pre-setup -> Record the amount of memory used
Do setup
Run test
Do teardown
Post-teardown -> Check whether the amount of memory is the same
The memory leak detector consists of three parts:
Memory leak detector base (including linker symbols for operator new)
Macros overloading operator new for additional file and line info
Macros overloading malloc/free for memory leak detection in C
All of these are on by default. For the macro support, you’ll need to add to your Makefile:
CXXFLAGS
+=
-include
$(CPPUTEST_HOME)
/include/CppUTest/MemoryLeakDetectorNewMacros.h
CFLAGS
+=
-include
$(CPPUTEST_HOME)
/include/CppUTest/MemoryLeakDetectorMallocMacros.h
These are added by default when you use the CppUTest Makefile helpers.
Turning memory leak detection off and on
If you want to disable the memory leak detection (because you have too many memory leaks?) then you can do so in several ways. However, it is strongly recommended to keep the memory leak detector on and fix your memory leaks (and your static initialization issues) as this tends to lead to higher quality code.
You can turn the memory leak detection completely off by adding this to your main:
int
main
(
int
argc
,
char
**
argv
)
{
MemoryLeakWarningPlugin
::
turnOffNewDeleteOverloads
();
return
CommandLineTestRunner
::
RunAllTests
(
argc
,
argv
);
}
You can do the same by turning it off on a test by test basis, by adding this to the test group:
void
setup
()
{
MemoryLeakWarningPlugin
::
saveAndDisableNewDeleteOverloads
();
}
void
teardown
()
{
MemoryLeakWarningPlugin
::
restoreNewDeleteOverloads
();
}
(Do not forget to restore it in the teardown again!)
If you want to completely disable memory leak detection then you can do so by building CppUTest with
configure --disable-memory-leak-detection
or passing
-DCPPUTEST_MEM_LEAK_DETECTION_DISABLED
to the compiler when compiling CppUTest.
Conflicts with operator new macros (STL!)
It is common for the memory leak detection macros to conflict with an overloaded operator new or with STL. This is because the macro replaces the call to operator new to a call to operator new with
__FILE__
, and
__LINE__
. If you overload operator new, it will replace your overloaded definition resulting in a compiler error. This is common when using the Standard C++ library (STL).
Resolving conflicts with STL
The easiest way is to not pass the
--include MemoryLeakDetectionNewMacros.h
to the compiler, but this would lose all your file and line information. So this is not recommended. An alternative is to create your own NewMacros.h file which will include the STL file
before
the new macro is defined. For example, the following NewMacros file can be used for a program that uses std::list:
#include ""list""
#include ""CppUTest/MemoryLeakDetectorNewMacros.h""
Now the call to the compiler needs to be -include MyOwnNewMacros.h and this will ensure that the operator new overload is
before
the define and thus all compiler errors are resolved.
Conflicts with my own overload!
This one is harder (and luckily less common). You can solve this the same way as the conflict with the STL, but it’s probably better to use a finer grained control. So, instead you can temporary disable the new macros, overload operator new, enable the new macro again. This can be done with the following code:
class
NewDummyClass
{
public:
#if CPPUTEST_USE_NEW_MACROS
#undef new
#endif
void
*
operator
new
(
size_t
size
,
int
additional
)
#if CPPUTEST_USE_NEW_MACROS
#include ""CppUTest/MemoryLeakDetectorNewMacros.h""
#endif
{
// Do your thing!
}
};
Yes, its ugly. But usually people don’t overload operator new everywhere. If you do, consider turning off the new macro completely.
Other conflicts in the test file only
If your conflict is only in the test code files, put the CppUTest  includes after your includes.  Because of this potential conflict, its a good idea to put the CppUTest includes after your includes as a preemptive measure.
Conflicts with MFC
Tbd
Test Plugins
Test plugins let you add a pre-action and a post-action to each test case.  Plugin examples:
Memory leak detector (provided)
Pointer restore mechanism (provided) - helpful when tests overwrite a pointer that must be restored to its original value after the test.  This is especially helpful when a pointer to a function is modified for test purposes.
IEEE754 Floating point exceptions (provided; v3.8) - automatically checks whether any floating point exception flags are set at the end of every test and if so, fails the test.
All Mutex’s released - you could write a plugin that checks that any Mutexs or other shared resource is released before the test exits.
Complete Documentation for provided plugins can be found on the
Plugin Manual
page.
Scripts
There are some scripts that are helpful in creating your initial header, source, and
Test files.  These scripts save a lot of typing.  See scripts/README.TXT from the CppUTest distribution.
Advanced
Customize CHECK_EQUAL to work with your types that support operator==()
Create the function
SimpleString
StringFrom
(
const
yourType
&
)
The Extensions directory has a few of these.
Building default checks with TestPlugin
CppUTest can support extra checking functionality by inserting TestPlugins
TestPlugin is derived from the TestPlugin class and can be inserted in the TestRegistry via the installPlugin method.
All TestPlugins are called before and after running all tests and before and after running a single test (like Setup and Teardown). TestPlugins are typically inserted in the main.
TestPlugins can be used for, for example, system stability and resource handling like files, memory or network connection clean-up.
In CppUTest, the memory leak detection is done via a default enabled TestPlugin
How to run tests when they are linked in a library
In larger projects, it is often useful if you can link the tests in “libraries of tests” and then link them to the library of a component or link them all together to be able to run all the unit tests. Putting the tests in a library however causes an interesting problem because the lack of reference to the tests (due to the auto-registration of tests) causes the linker to discard the tests and it won’t run any of them. There are two different work-arounds for this:
You can use the IMPORT_TEST_GROUP macro to create a reference. This is typically done in the main.cpp or the main.h. You’ll need to do this for every single TEST_GROUP (and the tests groups shouldn’t be distributed over multiple files)
When you use gnu linker (on linux, but not MacOSX) then you can use an additional linker option that will make sure the whole library is linked. You do this by adding the library to be linked between the “-Wl,-whole-archive” and the -Wl,-no-whole-archive” options. For example:
gcc
-o
test_executable
production_library.a
-Wl,-whole-archive
test_library.a
-Wl,-no-whole-archive
$(OTHER_LIBRARIES)
C Interface
Sometimes, a C header will not compile under C++. For such cases, there are macros that allow you to specify test cases in a .c source, without involving C++ at all. There are also macro wrappers that pull these test cases into a .cpp source for CppUTest to work with. You will find all C macro definitions in TestHarness_c.h.
Here is a small example of how this is done.
First, the header of the function we want to test, PureCTests.h:
/** Legal C code that would not compile under C++ */
int
private
(
int
new
);
Next, the C file that defines our tests, PureCTests.c:
#include ""PureCTests_c.h""
/** the offending C header */
#include ""CppUTest/TestHarness_c.h""
#include ""CppUtestExt/MockSupport_c.h""
/** Mock for function internal() */
int
internal
(
int
new
)
{
mock_c
()
->
actualCall
(
""internal""
)
->
withIntParameters
(
""new""
,
new
);
return
mock_c
()
->
returnValue
().
value
.
intValue
;
}
/** Implementation of function to test */
int
private
(
int
new
)
{
return
internal
(
new
);
}
/** Setup and Teardown per test group (optional) */
TEST_GROUP_C_SETUP
(
mygroup
)
{
}
TEST_GROUP_C_TEARDOWN
(
mygroup
)
{
mock_c
()
->
checkExpectations
();
mock_c
()
->
clear
();
}
/** The actual tests for this test group */
TEST_C
(
mygroup
,
test_success
)
{
mock_c
()
->
expectOneCall
(
""internal""
)
->
withIntParameters
(
""new""
,
5
)
->
andReturnIntValue
(
5
);
int
actual
=
private
(
5
);
CHECK_EQUAL_C_INT
(
5
,
actual
);
}
TEST_C
(
mygroup
,
test_mockfailure
)
{
mock_c
()
->
expectOneCall
(
""internal""
)
->
withIntParameters
(
""new""
,
2
)
->
andReturnIntValue
(
5
);
int
actual
=
private
(
5
);
CHECK_EQUAL_C_INT
(
5
,
actual
);
}
TEST_C
(
mygroup
,
test_equalfailure
)
{
mock_c
()
->
expectOneCall
(
""internal""
)
->
withIntParameters
(
""new""
,
5
)
->
andReturnIntValue
(
2
);
int
actual
=
private
(
5
);
CHECK_EQUAL_C_INT
(
5
,
actual
);
}
Finally, the .cpp file that wraps it all up for CppUTest, PureCTests.cpp:
#include ""CppUTest/CommandLineTestRunner.h""
#include ""CppUTest/TestHarness_c.h""
/** For each C test group */
TEST_GROUP_C_WRAPPER
(
mygroup
)
{
TEST_GROUP_C_SETUP_WRAPPER
(
mygroup
);
/** optional */
TEST_GROUP_C_TEARDOWN_WRAPPER
(
mygroup
);
/** optional */
};
/** For each C test */
TEST_C_WRAPPER
(
mygroup
,
test_success
);
TEST_C_WRAPPER
(
mygroup
,
test_mockfailure
);
TEST_C_WRAPPER
(
mygroup
,
test_equalfailure
);
/** Test main as usual */
int
main
(
int
ac
,
char
**
av
)
{
return
RUN_ALL_TESTS
(
ac
,
av
);
}
You can leave out TEST_GROUP_C_SETUP() / TEST_GROUP_C_TEARDOWN() and TEST_GROUP_C_SETUP_WRAPPER() / TEST_GROUP_C_TEARDOWN_WRAPPER(), if you don’t need them.
The following assertion macros are supported in the pure C interface:
CHECK_EQUAL_C_BOOL
(
expected
,
actual
);
CHECK_EQUAL_C_INT
(
expected
,
actual
);
CHECK_EQUAL_C_UINT
(
expected
,
actual
);
CHECK_EQUAL_C_LONG
(
expected
,
actual
);
CHECK_EQUAL_C_ULONG
(
expected
,
actual
);
CHECK_EQUAL_C_LONGLONG
(
expected
,
actual
);
CHECK_EQUAL_C_ULONGLONG
(
expected
,
actual
);
CHECK_EQUAL_C_REAL
(
expected
,
actual
,
threshold
);
CHECK_EQUAL_C_CHAR
(
expected
,
actual
);
CHECK_EQUAL_C_UBYTE
(
expected
,
actual
);
CHECK_EQUAL_C_SBYTE
(
expected
,
actual
);
CHECK_EQUAL_C_STRING
(
expected
,
actual
);
CHECK_EQUAL_C_POINTER
(
expected
,
actual
);
/* v3.8 */
CHECK_EQUAL_C_BITS
(
expected
,
actual
,
mask
);
/* v3.8, pending */
FAIL_TEXT_C
(
text
);
FAIL_C
();
CHECK_C
(
condition
);
CHECK_C_TEXT
(
condition
,
text
);
NOTE
LONGLONG assertions are disabled by default.
NOTE2
All macros have _TEXT() equivalents like CHECK_C_TEXT(), which are not explicitly listed here.
These macros ensure tests get terminated in a way appropriate for pure C code.
Using Google Mock
You can use Google Mock directly in CppUTest. In order to do this, you’ll need to build with the real google mock. You do that like this:
$
GMOCK_HOME
=
/location/of/gmock
$
configure
--enable-gmock
$
make
$
make
install
Then in your tests, you can #include “CppUTestExt/GMock.h”. Do remember to set the CPPUTEST_USE_REAL_GMOCK define (pass -DCPPUTEST_USE_REAL_GMOCK to the compiler). Also, do not forget to link the CppUTestExt library.
This way you can use GMock directly in your code. For example:
class
MyMock
:
public
ProductionInterface
{
public:
MOCK_METHOD0
(
methodName
,
int
());
};
TEST
(
TestUsingGMock
,
UsingMyMock
)
{
NiceMock
<
MyMock
>
mock
;
EXPECT_CALL
(
mock
,
methodName
()).
Times
(
2
).
WillRepeatedly
(
Return
(
1
));
productionCodeUsing
(
mock
);
}
The above will probably leak to the memory leak detector complaining about memory leaks (in google mock). These aren’t really memory leaks, but they are static data that gtest (unfortunately) allocates on the first run. There are a couple of ways to get around that. First, you turn of the memory leak detector (see
Memory Leak Detection
). A better solutions is to use the GTestConvertor.
You can do that by adding the following code to your main:
#include ""CppUTestExt/GTestConvertor.h""
int
main
(
int
argc
,
char
**
argv
)
{
GTestConvertor
convertor
;
return
CommandLineTestRunner
::
RunAllTests
(
argc
,
argv
);
}
The most important line to add is the GTestConvertor. Make sure you define the CPPUTEST_USE_REAL_GTEST to signal the gtest dependency. (by adding -DCPPUTEST_USE_REAL_GTEST to the compiler)
Running Google Tests in CppUTest
People feel wonderfully religious about unit testing tools. Of course, we feel strongly that CppUTest beats other tools when you actually test-drive your software. But unfortunately, people still use tools like GoogleTest (which is actually not as bad as e.g. CppUnit). It is unlikely that we’re going to convince people to use CppUTest instead, so therefore we’ve written some integration code where you can actually link google test and CppUTest tests together in one binary (with the CppUTest test runner). This also gives you some additional benefits:
You get memory leak detection over your google tests…
You don’t get the verbose gtest output
You can use both CppUMock and GMock in one project
The way to do this is really quite simple. First, you’ll need to compile CppUtest with the GTest support enabled (by default this is off to prevent the dependency with GTest). You do that this way (assuming you want to use GMock too):
$
GMOCK_HOME
=
/location/of/gmock
$
configure
--enable-gmock
$
make
$
make
install
Or, if you don’t want to use GMock and only GTest then:
$
GMOCK_HOME
=
/location/of/gtest
$
configure
--enable-real-gtest
$
make
$
make
install
To let CppUTest know there are gtest being linked, you’ll need to add the following to the main:
#include ""./include/CppUTestExt/GTestConvertor.h""
int
main
(
int
argc
,
char
**
argv
)
{
GTestConvertor
convertor
;
convertor
.
addAllGTestToTestRegistry
();
return
CommandLineTestRunner
::
RunAllTests
(
argc
,
argv
);
}
(of course, you’ll need make sure you link also gtest and also add it to the include path.)

jwgrenning
/
cpputest-starter-project
Public
Notifications
You must be signed in to change notification settings
Fork
55
Star
111
gcc cpputest starter project, with instructions to help get your legacy code into cpputest for the first time
License
MIT license
111
stars
55
forks
Branches
Tags
Activity
Star
Notifications
You must be signed in to change notification settings
Code
Issues
5
Pull requests
3
Actions
Projects
0
Wiki
Security
Insights
Additional navigation options
Code
Issues
Pull requests
Actions
Projects
Wiki
Security
Insights
jwgrenning/cpputest-starter-project
master
Branches
Tags
Go to file
Code
Folders and files
Name
Name
Last commit message
Last commit date
Latest commit
History
59 Commits
docker
docker
example-include
example-include
example-platform
example-platform
example-src
example-src
legacy-build
legacy-build
readme
readme
tests
tests
.gitignore
.gitignore
LICENSE
LICENSE
README.md
README.md
makefile
makefile
View all files
Repository files navigation
README
MIT license
cpputest-starter-project
The cpputest-starter-project can help you integrate CppUTest based off-target testing with your production code.
Integrate off-target testing into your development environment
Drop the whole starter project into your product source directory and evolve it into what you need.  You can clone or download this repo into your production code directory structure.  You will need to access your files from the
makefile
in the starter-kit directory using relative directory paths.
Clone the starter-kit like this:
cd <production-code-dir-root>
git clone https://github.com/jwgrenning/cpputest-starter-project unit-tests
Initial Example Product Repo Structure
your-project-root
|
|--- /cpputest (optionally in your repo)
|--- /include
|--- /src
|--- /platform
|--- makefile # for product build
|--- /legacy-build # scripts that help test existing code
|--- /unit-test # a.k.a the cpputest-starter-project
|
|--- example-include
|--- example-src
|--- example-platform
|--- tests
|--- makefile # for test-build
With the starter kit you have a working example.  So remember, it's easier to keep a system working than to fix after you break it.  So carefully morph the starer kit to be your own.
Handy things included
A failing test, ready to help bootstrap your first test.
MockIO examples
Fake Function Framework (FFF) examples
A spy implementation to override
printf
and capture printed output.
Legacy build scripts
with exploding fakes generator.
Run the starter-project tests
There are two basic approaches supported here.
Using Docker (preferred)
Using an installed tool-chain (subject to 'works on my machine' problems)
Run Tests in a Docker Container (preferred)
You can run your tests without any tool-chain installed in your local machine with docker. You will need to  install docker.  With docker, you will have an
image
of a machine that can be run in a
container
.  Think of it as a lightweight and pre-configured virtual machine.
Install Docker
For Mac: start here
https://docs.docker.com/desktop/mac/install/
For Windows: start here
https://docs.docker.com/desktop/windows/install/
For Linux: search for instructions for your system.
Get or build a test-runner
You can use my pre-built test-runner docker image, or you can build your own with the provided bash scripts.  Windows users, you'll need to translate the scripts for windows. All my examples here use bash.
Using the pre-built test-runner docker image
Pull the
jwgrenning/cpputest-runner
docker image from docker hub.
sudo docker pull jwgrenning/cpputest-runner
Run the image in a container
cd your-project-root
./unit-tests/docker/run.sh ""make -C unit-test""
You'll see something like this
compiling AllTests.cpp
compiling ExampleTest.cpp
compiling MyFirstTest.cpp
compiling io_CppUMock.cpp
compiling io_CppUMockTest.cpp
compiling FormatOutputSpyTest.cpp
compiling FormatOutput.c
compiling FormatOutputSpy.c
compiling io.c
compiling Example.c
Building archive test-lib/libyour.a
a - test-obj/example-platform/io.o
a - test-obj/example-src/Example.o
Linking your_tests
Running your_tests
.......
tests/MyFirstTest.cpp:23: error: Failure in TEST(MyCode, test1)
Your test is running! Now delete this line and watch your test pass.
..
Errors (1 failures, 9 tests, 9 ran, 15 checks, 0 ignored, 0 filtered out, 1 ms)
make: *** [/home/cpputest/build/MakefileWorker.mk:458: all] Error 1
You are ready to write your first test!
What can the running docker container access?
Executing
docker/run.sh
from
your-project-root/
means that the files and directories in
your-project-root/
are visible to the docker container. You will be able to reference your files from
tests/makefile
.  Any header and source file dependencies needed by the code under test should also be accessible from
your-project-root/
.
Make clean
You can make clean.
./your-project-root/docker/run.sh ""make -C unit-test clean""
Run legacy-build
You can run the
legacy-build
script.  This script is helpful when you are dragging never tested code into the test environment. See
legacy-build
for more information.
./your-project-root/docker/run.sh ""legacy-build make unit-test .""
This runs the
legacy-build
script, which
runs
make
from the container's
unit-test
directory,
with the container's
.
directory as the directory to search for missing include dependencies.
Open a shell prompt in the container
./your-project-root/docker/run.sh
You'll see something like this
root@a564a6d5ee5b:/home#
Note that
/home
refers to
./your-project-root/
From the prompt, you can execute commands like this:
make -C unit-test
legacy-build make unit-test .
Runs
make
from the
unit-test
directory, and uses the current directory (
.
) as the root of the tree to search for missing include files.
Mount Other Directories in the Container
You can mount other directories in your container by making
docker/run.sh
your own.
Given some directory holding needed dependencies, map it into the container.
DIR_ON_HOST=/some/path/to/something
DIR_IN_CONTAINER=/home/something
Add something like this to the
docker run
command options.  Don't forget the trailing
\
to escape the newline.
--volume ""${DIR_ON_HOST}"":""${DIR_IN_CONTAINER}"" \
Make the Docker environment your own
Now that I've got you started, you may want to make this your own.  You can modify
docker/build.sh
and
docker/run.sh
scripts as needed.  You will want to change the
TAG
if you plan on pushing your image to docker hub so you can share it between machines.
We've only scratched the surface of the Docker's capabilities.
Run Tests with an Installed Tool-Chain
1) Install gcc tool-chain
Mac and Linux
In Mac and Linux you will need gcc, make and autotools.
Windows Cygwin
In windows, I find cygwin (
http://www.cygwin.com/
) is the least trouble,  The install may take a couple hours.  Make sure to select the ‘Devel’ package in the installer.
Windows with Linux Virtual Machine
(consider the docker approach)
Set up a linux virtual machine on windows is by enabling the Windows Subsytem for Linux (WSL), and then downloading your preferred linux flavor from the Windows App store (WSL setup tutorial:
https://docs.microsoft.com/en-us/windows/wsl/install-win10
). CppUTest can then be installed from source via the WSL / linux terminal. After CppUTest is installed the starter project can be run using WSL and a linux terminal, after the following tools have been installed in the linux terminal: gcc, make, and GNU autotools.
2) Download, Install and build CppUTest
Download the latest from cpputest.org.  It is best to put it into a directory near your production code so it can be checked into your source repository.  You can also make CppUTest part of your git repo using a
git submodule
.
git submodule add https://github.com/cpputest/cpputest.git
NOTE: My starter kit is not compatible with some of the install methods described on cpputest.org. You cannot ‘apt-get install cpputest’ for use with my starter kit.  Please install it as follows:
cd /close-to-your-production-code/cpputest
autoreconf . -i
./configure
make tdd
You should see CppUTest’s tests run.  If you get build errors, they are often easy to fix by looking at the error message.  Often it is a matter of disabling some warning.  You can also check with me or the cpputest google group.  Please let me know if there is a need for a change these directions.
3) Define CPPUTEST_HOME
Point CPPUTEST_HOME to the root directory of CppUTest.  If you don't, the starter project makefile will not be able to find MakefileWorker.mk and the needed include and library files.
export CPPUTEST_HOME=/close-to-your-production-code/cpputest
Under cygwin, you can use a windows environment variable.
4) Build the starter project
From a terminal window, change the directory to the root of the starter project. The same directory where this file was found. The make all.
cd /close-to-your-production-code/cpputest-starter-project
make all
You should see output announcing each file compiling and finally running the tests like this (don't worry if the numbers don't match):
compiling AllTests.cpp
compiling ExampleTest.cpp
compiling MyFirstTest.cpp
compiling io_CppUMock.cpp
compiling io_CppUMockTest.cpp
compiling FormatOutputSpyTest.cpp
compiling FormatOutput.c
compiling FormatOutputSpy.c
compiling io.c
compiling Example.c
Building archive test-lib/libyour.a
a - test-obj/example-platform/io.o
a - test-obj/example-src/Example.o
Linking your_tests
Running your_tests
.......
tests/MyFirstTest.cpp:23: error: Failure in TEST(MyCode, test1)
Your test is running! Now delete this line and watch your test pass.
..
Errors (1 failures, 9 tests, 9 ran, 15 checks, 0 ignored, 0 filtered out, 1 ms)
make: *** [/home/cpputest/build/MakefileWorker.mk:458: all] Error 1
Make MyFirstTest Pass
Edit cpputest-starter-project/tests/MyFirstTest.cpp and delete the line containing the FAIL. Watch the test pass.
compiling MyFirstTest.cpp
Linking your_tests
Running your_tests
.........
OK (9 tests, 9 ran, 14 checks, 0 ignored, 0 filtered out, 0 ms)
You are ready to start your first test.  The easiest way I have found is to follow this recipe:
Get Your Legacy C into a Test Harness
On that page you'll find the recipe and a number of articles of specific problems you may run into.
Keep working in small verifiable steps.
It's easier to keep your code working than to fix it after you break it!
Try the legacy-build script.  It is included in the docker image.  It will help track down include dependencies and also generate exploding fakes when you get to linker errors.
About
gcc cpputest starter project, with instructions to help get your legacy code into cpputest for the first time
Resources
Readme
License
MIT license
Activity
Stars
111
stars
Watchers
6
watching
Forks
55
forks
Report repository
Releases
No releases published
Packages
0
No packages published
Contributors
6
Languages
C
63.9%
Shell
14.8%
C++
9.8%
Rich Text Format
5.7%
Makefile
4.9%
Dockerfile
0.9%

cpputest
/
cpputest
Public
Notifications
You must be signed in to change notification settings
Fork
516
Star
1.4k
CppUTest unit testing and mocking framework for C/C++
cpputest.github.io
License
BSD-3-Clause license
1.4k
stars
516
forks
Branches
Tags
Activity
Star
Notifications
You must be signed in to change notification settings
Code
Issues
168
Pull requests
19
Discussions
Actions
Projects
0
Security
Insights
Additional navigation options
Code
Issues
Pull requests
Discussions
Actions
Projects
Security
Insights
cpputest/cpputest
master
Branches
Tags
Go to file
Code
Folders and files
Name
Name
Last commit message
Last commit date
Latest commit
History
4,605 Commits
.circleci
.circleci
.github/
workflows
.github/
workflows
build
build
builds
builds
cmake
cmake
docker
docker
examples
examples
include
include
m4
m4
platforms
platforms
platforms_examples
platforms_examples
scripts
scripts
src
src
tests
tests
.clang-format
.clang-format
.clang-tidy
.clang-tidy
.git-blame-ignore-revs
.git-blame-ignore-revs
.gitattributes
.gitattributes
.gitignore
.gitignore
.travis.yml
.travis.yml
AUTHORS
AUTHORS
CMakeLists.txt
CMakeLists.txt
CMakePresets.json
CMakePresets.json
COPYING
COPYING
ChangeLog
ChangeLog
CppUTest.sln
CppUTest.sln
CppUTest.vcproj
CppUTest.vcproj
CppUTest.vcxproj
CppUTest.vcxproj
CppUTestConfig.cmake.build.in
CppUTestConfig.cmake.build.in
CppUTestConfig.cmake.install.in
CppUTestConfig.cmake.install.in
CppUTest_VS201x.sln
CppUTest_VS201x.sln
Doxyfile
Doxyfile
Makefile.am
Makefile.am
Makefile_CppUTestExt
Makefile_CppUTestExt
Makefile_using_MakefileWorker
Makefile_using_MakefileWorker
NEWS
NEWS
README
README
README.md
README.md
README_CppUTest_for_C.txt
README_CppUTest_for_C.txt
README_InstallCppUTest.txt
README_InstallCppUTest.txt
appveyor.yml
appveyor.yml
autogen.sh
autogen.sh
config.h.cmake
config.h.cmake
configure.ac
configure.ac
cpputest.pc.in
cpputest.pc.in
cpputest_doxy_gen.conf
cpputest_doxy_gen.conf
gcovr.cfg
gcovr.cfg
makeVS2008.bat
makeVS2008.bat
makeVS201x.bat
makeVS201x.bat
valgrind.suppressions
valgrind.suppressions
View all files
Repository files navigation
README
BSD-3-Clause license
CppUTest
CppUTest unit testing and mocking framework for C/C++
More information on the project page
Slack channel:
Join if link not expired
Getting Started
You'll need to do the following to get started:
Building from source (Unix-based, Cygwin, MacOS):
git clone https://github.com/cpputest/cpputest.git
cd
cpputest
mkdir cpputest_build
cd
cpputest_build
autoreconf .. -i
../configure
make
You can use
make install
if you want to install CppUTest system-wide.
You can also use CMake, which also works for Windows Visual Studio.
git clone https://github.com/cpputest/cpputest.git
cd
cpputest
mkdir cpputest_build
cmake -B cpputest_build
cmake --build cpputest_build
Then to get started, you'll need to do the following:
Add the include path to the Makefile. Something like:
CPPFLAGS += -I$(CPPUTEST_HOME)/include
Add the memory leak macros to your Makefile (needed for additional debug info!). Something like:
CXXFLAGS += -include $(CPPUTEST_HOME)/include/CppUTest/MemoryLeakDetectorNewMacros.h
CFLAGS += -include $(CPPUTEST_HOME)/include/CppUTest/MemoryLeakDetectorMallocMacros.h
Add the library linking to your Makefile. Something like:
LD_LIBRARIES = -L$(CPPUTEST_HOME)/lib -lCppUTest -lCppUTestExt
After this, you can write your first test:
TEST_GROUP
(FirstTestGroup)
{
};
TEST
(FirstTestGroup, FirstTest)
{
FAIL
(
""
Fail me!
""
);
}
You can build and install cpputest using
vcpkg
dependency manager:
$
vcpkg install cpputest (More information: https://github.com/microsoft/vcpkg)
Command line switches
-h
help, shows the latest help, including the parameters we've implemented after updating this README page.
-v
verbose, print each test name as it runs
-r#
repeat the tests some number of times, default is one, default if # is not specified is 2. This is handy if you are experiencing memory leaks related to statics and caches.
-s#
random shuffle the test execution order. # is an integer used for seeding the random number generator. # is optional, and if omitted, the seed value is chosen automatically, which results in a different order every time. The seed value is printed to console to make it possible to reproduce a previously generated execution order. Handy for detecting problems related to dependencies between tests.
-g
group only run test whose group contains the substring group
-n
name only run test whose name contains the substring name
-f
crash on fail, run the tests as normal but, when a test fails, crash rather than report the failure in the normal way
Test Macros
TEST(group, name)
- define a test
IGNORE_TEST(group, name)
- turn off the execution of a test
TEST_GROUP(group)
- Declare a test group to which certain tests belong. This will also create the link needed from another library.
TEST_GROUP_BASE(group, base)
- Same as
TEST_GROUP
, just use a different base class than Utest
TEST_SETUP()
- Declare a void setup method in a
TEST_GROUP
- this is the same as declaring void
setup()
TEST_TEARDOWN()
- Declare a void setup method in a
TEST_GROUP
IMPORT_TEST_GROUP(group)
- Export the name of a test group so it can be linked in from a library. Needs to be done in
main
.
Set up and tear down support
Each
TEST_GROUP
may contain a
setup
and/or a
teardown
method.
setup()
is called prior to each
TEST
body and
teardown()
is called after the test body.
Assertion Macros
The failure of one of these macros causes the current test to immediately exit
CHECK(boolean condition)
- checks any boolean result
CHECK_TRUE(boolean condition)
- checks for true
CHECK_FALSE(boolean condition)
- checks for false
CHECK_EQUAL(expected, actual)
- checks for equality between entities using
==
. So if you have a class that supports
operator==()
you can use this macro to compare two instances.
STRCMP_EQUAL(expected, actual)
- check const
char*
strings for equality using
strcmp
LONGS_EQUAL(expected, actual)
- Compares two numbers
BYTES_EQUAL(expected, actual)
- Compares two numbers, eight bits wide
POINTERS_EQUAL(expected, actual)
- Compares two
const void *
DOUBLES_EQUAL(expected, actual, tolerance)
- Compares two doubles within some tolerance
ENUMS_EQUAL_INT(excepted, actual)
- Compares two enums which their underlying type is
int
ENUMS_EQUAL_TYPE(underlying_type, excepted, actual)
- Compares two enums which they have the same underlying type
FAIL(text)
- always fails
TEST_EXIT
- Exit the test without failure - useful for contract testing (implementing an assert fake)
Customize
CHECK_EQUAL
to work with your types that support
operator==()
Create the function:
SimpleString StringFrom(const yourType&)
The Extensions directory has a few of these.
Building default checks with TestPlugin
CppUTest can support extra checking functionality by inserting TestPlugins
TestPlugin is derived from the TestPlugin class and can be inserted in the TestRegistry via the installPlugin method.
TestPlugins can be used for, for example, system stability and resource handling like files, memory or network connection clean-up.
In CppUTest, the memory leak detection is done via a default enabled TestPlugin
Example of a main with a TestPlugin:
int
main
(
int
ac,
char
** av)
{
LogPlugin logPlugin;
TestRegistry::getCurrentRegistry
()->
installPlugin
(&logPlugin);
int
result =
CommandLineTestRunner::RunAllTests
(ac, av);
TestRegistry::getCurrentRegistry
()->
resetPlugins
();
return
result;
}
Memory leak detection
A platform specific memory leak detection mechanism is provided.
If a test fails and has allocated memory prior to the fail and that memory is not cleaned up by TearDown, a memory leak is reported.
It is best to only chase memory leaks when other errors have been eliminated.
Some code uses lazy initialization and appears to leak when it really does not (for example: gcc stringstream used to in an earlier release). One cause is that some standard library calls allocate something and do not free it until after
main
(or never).
To find out if a memory leak is due to lazy initialization set the
-r
switch to run tests twice. The signature of this situation is that the first run shows leaks and the second run shows no leaks. When both runs show leaks, you have a leak to find.
How is memory leak detection implemented?
Before
setup()
a memory usage checkpoint is recorded
After
teardown()
another checkpoint is taken and compared to the original checkpoint
In Visual Studio the MS debug heap capabilities are used
For GCC a simple new/delete count is used in overridden operators
new
,
new[]
,
delete
and
delete[]
If you use some leaky code that you can't or won't fix you can tell a TEST to ignore a certain number of leaks as in this example:
TEST
(MemoryLeakWarningTest, Ignore1)
{
EXPECT_N_LEAKS
(
1
);
char
* arrayToLeak1 =
new
char
[
100
];
}
Example Main
#
include
""
CppUTest/CommandLineTestRunner.h
""
int
main
(
int
ac,
char
** av)
{
return
RUN_ALL_TESTS
(ac, av);
}
Example Test
#
include
""
CppUTest/TestHarness.h
""
#
include
""
ClassName.h
""
TEST_GROUP
(ClassName)
{
ClassName* className;
void
setup
()
{
className =
new
ClassName
();
}
void
teardown
()
{
delete
className;
}
};
TEST
(ClassName, Create)
{
CHECK
(
0
!= className);
CHECK
(
true
);
CHECK_EQUAL
(
1
,
1
);
LONGS_EQUAL
(
1
,
1
);
DOUBLES_EQUAL
(
1.000
,
1.001
, .
01
);
STRCMP_EQUAL
(
""
hello
""
,
""
hello
""
);
FAIL
(
""
The prior tests pass, but this one doesn't
""
);
}
There are some scripts that are helpful in creating your initial h, cpp, and
Test files. See scripts/README.TXT
Conan
CppUTest is available through
conan-center
.
conanfile.txt
[requires]
cpputest/4.0
[generators]
cmake_find_package
cmake_paths
CMake
find_package
(CppUTest REQUIRED)
add_executable
(example_test ExampleTest.cpp)
target_link_libraries
(example_test
PRIVATE
CppUTest::CppUTest
CppUTest::CppUTestExt)
Integration as external CMake project
Sometimes you want to use CppUTest in your project without installing it to your system or for having control over the version you are using. This little snippet get the wanted version from GitHub and builds it as a library.
# CppUTest
include
(FetchContent)
FetchContent_Declare(
CppUTest
GIT_REPOSITORY https://github.com/cpputest/cpputest.git
GIT_TAG        master
# or use release tag, eg. v4.0
)
# Set this to ON if you want to have the CppUTests in your project as well.
set
(TESTS
OFF
CACHE
BOOL
""Switch off CppUTest Test build""
)
FetchContent_MakeAvailable(CppUTest)
It can be used then like so:
add_executable
(run_tests UnitTest1.cpp UnitTest2.cpp)
target_link_libraries
(example_test
PRIVATE
CppUTest::CppUTest
CppUTest::CppUTestExt)
About
CppUTest unit testing and mocking framework for C/C++
cpputest.github.io
Topics
c-plus-plus
unit-testing
test-driven-development
cpputest
very-kewl
memory-leak
mocking-framework
Resources
Readme
License
BSD-3-Clause license
Activity
Custom properties
Stars
1.4k
stars
Watchers
87
watching
Forks
516
forks
Report repository
Releases
7
Latest passing build
Latest
Apr 23, 2020
+ 6 releases
Packages
0
No packages published
Contributors
119
+ 105 contributors
Languages
C++
82.8%
C
4.0%
M4
4.0%
Makefile
3.7%
CMake
2.4%
Shell
1.3%
Other
1.8%

jwgrenning
Follow
Overview
Repositories
29
Projects
0
Packages
0
Stars
2
More
Overview
Repositories
Projects
Packages
Stars
jwgrenning
Follow
James Grenning
jwgrenning
Follow
I coach and train engineers learning TDD. I also build some products.
320
followers
·
0
following
Wingman Software
Bonita Springs, Florida
www.wingman-sw.com
Achievements
x2
Achievements
x2
Organizations
Block or Report
Block or report jwgrenning
Block user
Prevent this user from interacting with your repositories and sending you notifications.
Learn more about
blocking users
.
You must be logged in to block users.
Add an optional note:
Please don't include any personal information such as legal names or email addresses. Maximum 100 characters, markdown supported. This note will be visible to only you.
Block user
Report abuse
Contact GitHub support about this user’s behavior.
Learn more about
reporting abuse
.
Report abuse
Overview
Repositories
29
Projects
0
Packages
0
Stars
2
More
Overview
Repositories
Projects
Packages
Stars
Popular repositories
Loading
tddec-code
tddec-code
Public
Book code for Test-Driven Development for Embedded C
C
256
90
cpputest-starter-project
cpputest-starter-project
Public
gcc cpputest starter project, with instructions to help get your legacy code into cpputest for the first time
C
111
55
legacy-build
legacy-build
Public
Generate exploding fakes from c/c++ linker error output (used for unit testing)
Shell
42
5
cpputest-starter-project-vs
cpputest-starter-project-vs
Public
A cpputest starter project with instructions for visual studio
C
20
12
flash-driver-cmocka
flash-driver-cmocka
Public
Example of using cmocka c test framework, and TDD
C
8
2
problems-with-extended-c
problems-with-extended-c
Public
This is an example of getting some micro-controller 'extended' c code under test.
C
5
2
Something went wrong, please refresh the page to try again.
If the problem persists, check the
GitHub status page
or
contact support
.

Cpputest
CppUTest unit testing and mocking framework for C/C++
CppUTest
Core Manual
CppUMock Manual
Plugin Manual
Platforms stories
View on
GitHub
Download Release 3.8 as .zip
Download Release 3.8 as .tar.gz
Download Latest Passing Build .zip
Download Latest Passing Build .tar.gz
Useful CppUTest Application Stories"
Unit Testing With IAR Embedded Workbench,"Guide to setup CppUTest for Eclipse in Windows 7
Unit Testing With IAR Embedded Workbench
By Heath Raftery
The original post in CppUTest google group
I’ve just completed an assessment of CppUTest for adoption as our company’s standard Unit Testing framework. It was a bit of a battle at times but I’ve come out victorious so would like to share my experience for three reasons: see if there’s anything I could be doing better; provide a crumb trail for other pioneers; and also contribute to CppUTest itself.
One of our strict criteria is compatibility with IAR Embedded Workbench 6.4 projects. We don’t want to have to maintain a separate build environment just to run tests. Here’s what I found:
Pulling from git source was best way to download, since that simultaneously allows us to make local changes to enable a build and store it all in our own repositories, while still allowing synchronisation with changes to the CppUTest source. As a bonus, for our users that don’t want to know about git, as far as they’re concerned they’re pulling the software from our (SVN) repository.
To build the CppUTest library in IAR, I created a new empty IAR project in the root folder of cpputest and made the following changes:
Project -> Options -> General Options -> Target -> Core = Cortex-M3.
Project -> Options -> General Options -> Output -> Output file = Library
Project -> Options -> General Options -> Output -> Executables/libraries = Debug (removed exe subdirectory)
Project -> Options -> C/C++ Compiler -> Language 1 -> Language = C++
Project -> Options -> C/C++ Compiler -> Language 1 -> Language conformance =  Standard
Project -> Options -> C/C++ Compiler -> Language 1 -> C++ Dialect = C++ (leave exceptions checked)
Project -> Options -> C/C++ Compiler -> Preprocessor -> Additional include directories = $PROJ_DIR$\include
Project -> Options -> C/C++ Compiler -> Diagnostics -> Suppress these diagnostics = Pa050 (turn off warning about non-standard line endings)
Added all .cpp files in src\CppUTest\
Added src\Platforms\Iar\UtestPlatform.cpp
Changed line 89 of UtestPlatform.cpp from return 1; to return t; which enables timing.
CppUTest then builds successfully in both Debug and Release configurations, producing a CppUTest.a file
To build the CppUTest tests, I created a new empty IAR project in the root folder of cpputest, called it CppUTestTest, and made the following changes:
Project -> Options -> General Options -> Target -> Core = Cortex-M3.
Project -> Options -> General Options -> Library Configuration -> Library low-level interface implementation = Semihosted
Project -> Options -> C/C++ Compiler -> Language 1 -> Language = Auto
Project -> Options -> C/C++ Compiler -> Language 1 -> Language conformance =  Standard
Project -> Options -> C/C++ Compiler -> Language 1 -> C++ Dialect = C++ (leave exceptions checked)
Project -> Options -> C/C++ Compiler -> Preprocessor -> Additional include directories = $PROJ_DIR$\include
Project -> Options -> C/C++ Compiler -> Diagnostics -> Suppress these diagnostics = Pa050 (turn off warning about non-standard line endings)
Project -> Options -> Linker -> Config -> Override default -> Edit -> Stack/Heap Sizes -> CSTACK = 0x600
Project -> Options -> Linker -> Config -> Override default -> Edit -> Stack/Heap Sizes -> HEAP =  0x8000
Added all .cpp and .c files in tests\
Added Debug\CppUTest.a
Changed line 16 of tests\AllocLetTestFree.c to explicit cast to (AllocLetTestFree) to satisfy compiler
Changed line 22 of tests\AllocLetTestFree.c to type AllocLetTestFree instead of void* to satisfy compiler
Changed tests\AllTests.cpp to declare a const char*[] with ""-v"" as the second element, so it can be passed to RunAllTests to turn on verbose mode in IAR
Built and ran in simulator.
Turned on Debug->C++ Exceptions->Break on uncaught exception to intercept mysterious jumps to abort.
With that out of the way I did the same for CppUTestExt and CppUTestExtTester, with no further dramas.
The stack/heap allocations were probably the largest source of drama, firstly because it wasn’t clear that an out of memory situation had occurred. If the heap was exhausted a malloc/new would return zero, throw an exception and the debugger would jump to abort with no sign of the offensive statement. Turning on “Break on uncaught exception” helped. If the stack was exhausted, program behaviour was very hard to predict, and often it was in the course of trying to print out a useful error message that the stack would get corrupted! I found values of 0x600 and 0x8000 were narrowly enough to allow completion execution of the tests. It was a very tight fit though, since the Cortex-M3 architecture in IAR has 64kB of RAM on chip. With those allocations the map file showed these totals for the RAM region:
Static: 21056 bytes
Heap: 32768 bytes
iar.dynexit (atexit statics): 8760
Stack:  1536 bytes
Total:  64120 bytes out of 65535 bytes.
Turning off “Destroy static objects” might have given us another 8760 bytes to play with, but it’s still pretty tight.
As already noted, I also needed to make two changes to the source to build and run correctly. As far as I can see, these could be applied to the master:
src\Platforms\Iar\UtestPlatform.cpp:89 (return t;)
tests\AllocLetTestFree.c:16 and  tests\AllocLetTestFree.c:22 (explicit types)
The third change to AllTests.cpp will probably only be important for IAR users, because there’s no option to set command line arguments of the target executable in IAR.
With the libraries and their tests built and run successfully, the next step was to create a test for a real project. I found the following to be a suitable procedure:
Add a folder called tests to the target project’s source hierarchy.
Create AllTests.cpp with this content:
#include ""CppUTest/CommandLineTestRunner.h""
int
main
(
int
ac
,
char
**
av
)
{
const
char
*
av_override
[]
=
{
""exe""
,
""-v""
};
//turn on verbose mode
//return CommandLineTestRunner::RunAllTests(ac, av);
return
CommandLineTestRunner
::
RunAllTests
(
2
,
av_override
);
}
And
create
MyCodeTest
.
cpp
with
this
content
:
extern
""C""
{
#include ""..\MyCode.h""
}
#include ""CppUTest/TestHarness.h""
TEST_GROUP
(
FirstTestGroup
)
{
void
setup
()
{}
void
teardown
()
{}
};
TEST
(
FirstTestGroup
,
FirstTest
)
{
FAIL
(
""Fail me!""
);
}
TEST
(
FirstTestGroup
,
SecondTest
)
{
STRCMP_EQUAL
(
""hello""
,
""world""
);
}
Then in the same directory as your target project’s project file, create a new C++ main project called MyProjectTest. Make the following changes to Project -> Options:
General Options -> change Device to your target device
General Options -> Library Configuration -> check ""Use CMSIS"" if it used in your target project
C/C++ Compiler -> Language 1 -> Language = Auto
C/C++ Compiler -> Language 1 -> C++ Dialect = C++
C/C++ Compiler -> Preprocessor -> Additional include directories = path\to\cpputest\include
C/C++ Compiler -> Preprocessor -> add any necessary #defines from the target project to Defined symbols
C/C++ Compiler -> Diagnostics -> Suppress these diagnostics = Pa050
Linker -> Config -> Override default with icf file used by target project
Ensure CSTACK is at least 0x600 and HEAP is at least 0x5000. If your target project already uses those regions, expand accordingly, otherwise ensure they’re placed somewhere where they’ll fit.
Remove main.cpp and add AllTests.cpp, MyCodeTest.cpp and Debug\CppUTest.a (use Debug version so breakpoints can be used in code and there’s an inconsequential performance/size hit).
Create a new Group called src and add source files from the target project as necessary.
Use the simulator to debug the executable and run the tests.
Show the Terminal I/O window to see the output. In non-verbose mode a dot is written for a successful test and an exclamation mark for an ignored test.
There’s lots of other details to be considered such as Workspaces, build configurations, and what to do when things go wrong, but hopefully that’s enough to get started.
So that’s about it. At the end of the day, CppUTest looks like it will meet our needs nicely. Once the initial setup is done, it integrates well into IAR and the output is readable within the IDE. The simulator provides a suitable alternative to execution on the PC (which means having to maintain a build with a different compiler) and execution on the hardware (which requires working hardware, Flash writes, functioning peripherals and is difficult to inject test vectors into).
Guide to setup CppUTest for Eclipse in Windows 7
By Miguel Mora Perea
Can be found
at the github page
Guide to setup CppUTest with Windows 10 with WSL
By Rob Baragona
Can be found
at the github page

Cpputest
CppUTest unit testing and mocking framework for C/C++
CppUTest
Core Manual
CppUMock Manual
Plugin Manual
Platforms stories
View on
GitHub
Download Release 3.8 as .zip
Download Release 3.8 as .tar.gz
Download Latest Passing Build .zip
Download Latest Passing Build .tar.gz
CppUTest has support for building mocks. This document describes the mocking support. A couple of design goals for the mocking support were:
Same design goals as CppuTest – limited C++ set to make it suitable for embedded software.
No code generation
No or very few magic hiding macros
Very simple to use
The developer stays in control
The main idea is to make manual mocking easier, rather than to make automated mocks. If manual mocking is easier, then it could also be automated in the future, but that isn’t a goal by itself."
Simple Scenario,"Using Objects
Using Parameters
Objects as Parameters
Output Parameters
Output Parameters Using Objects
Return Values
Passing other data
Other MockSupport
MockSupport Scope
MockSupportPlugin
C Interface
Miscellaneous
Simple Scenario
About the simplest scenario is to check that one particular function call has happened. The below code is an example of this:
#include ""CppUTest/TestHarness.h""
#include ""CppUTestExt/MockSupport.h""
TEST_GROUP
(
MockDocumentation
)
{
void
teardown
()
{
mock
().
clear
();
}
};
void
productionCode
()
{
mock
().
actualCall
(
""productionCode""
);
}
TEST
(
MockDocumentation
,
SimpleScenario
)
{
mock
().
expectOneCall
(
""productionCode""
);
productionCode
();
mock
().
checkExpectations
();
}
The only additional include for mocking is CppUTestExt/MockSupport.h which is the main include for anything CppUTest Mocking. The declaration of the TEST_GROUP is the same as always, there is no difference.
The TEST(MockDocumentation, SimpleScenario) contains the recording of the expectations as:
mock
().
expectOneCall
(
""productionCode""
);
The call to mock() returns the global MockSupport (more about that later) on which we can record our expectations. In this example, we’ll call expectOneCall(“productionCode”) which… records an expectation for
one
call to a function called productionCode.
The productionCode call is to show a call to whatever your real code is. The test ends with checking whether the expectations have been met. This is done with the:
mock
().
checkExpectations
();
This call is needed when
not
using the MockSupportPlugin, otherwise this is done automatically for every single test. Also, the call to mock().clear() in the teardown is
not
needed when using the MockSupportPlugin, otherwise it is needed to clear the MockSupport. Without the clear, the memory leak detector will report the mock calls as leaks.
The actual mocked function call looks like:
void
productionCode
()
{
mock
().
actualCall
(
""productionCode""
);
}
where we use MockSupport by calling mock() and then record the actual call to the productionCode function.
This scenario is quite common when using linker stubbing of e.g. a 3rd party library.
If the call to productionCode wouldn’t happen, then the test would fail with the following error message:
ApplicationLib/MockDocumentationTest.cpp:41: error: Failure in TEST(MockDocumentation, SimpleScenario)
Mock Failure: Expected call did not happen.
EXPECTED calls that did NOT happen:
productionCode -> no parameters
ACTUAL calls that did happen:
<none>
Sometimes you expect
several identical calls
to the same function, for example five calls to productionCode. There is a convenient shorthand for that situation:
mock
().
expectNCalls
(
5
,
""productionCode""
);
Using Objects
Simple scenario using objects
There is no difference between mocking functions and objects. Below code shows a mock using run-time mocking:
class
ClassFromProductionCodeMock
:
public
ClassFromProductionCode
{
public:
virtual
void
importantFunction
()
{
mock
().
actualCall
(
""importantFunction""
);
}
};
TEST
(
MockDocumentation
,
SimpleScenarioObject
)
{
mock
().
expectOneCall
(
""importantFunction""
);
ClassFromProductionCode
*
object
=
new
ClassFromProductionCodeMock
;
/* create mock instead of real thing */
object
->
importantFunction
();
mock
().
checkExpectations
();
delete
object
;
}
The code is self-explanatory. The real object is replaced by a hand-made mock object. The call to the mock then records the actual call via the MockSupport.
When using objects, we can also check whether the call was done on the right object, via this:
mock
().
expectOneCall
(
""importantFunction""
).
onObject
(
object
);
and the actual call would then be:
mock
().
actualCall
(
""importantFunction""
).
onObject
(
this
);
If the call to a wrong object happens, it would give the following error message:
MockFailure: Function called on a unexpected object: importantFunction
Actual object for call has address: <0x1001003e8>
EXPECTED calls that DID NOT happen related to function: importantFunction
(object address: 0x1001003e0)::importantFunction -> no parameters
ACTUAL calls that DID happen related to function: importantFunction
<none>
Parameters
Of course, just checking whether a function is called is not particularly useful when we cannot check the parameters. Recording parameters on a function is done like this:
mock
().
expectOneCall
(
""function""
).
onObject
(
object
).
withParameter
(
""p1""
,
2
).
withParameter
(
""p2""
,
""hah""
);
And the actual call is like:
mock
().
actualCall
(
""function""
).
onObject
(
this
).
withParameter
(
""p1""
,
p1
).
withParameter
(
""p2""
,
p2
);
If a parameter isn’t passed, it will give the following error:
Mock Failure: Expected parameter for function ""function"" did not happen.
EXPECTED calls that DID NOT happen related to function: function
(object address: 0x1)::function -> int p1: <2>, char* p2: <hah>
ACTUAL calls that DID happen related to function: function
<none>
MISSING parameters that didn't happen:
int p1, char* p2
Objects as Parameters
withParameters can only use int, double, const char* or void* . However, parameters are often objects of other types and not of the basic types. How to handle objects as parameters? Below is an example:
mock
().
expectOneCall
(
""function""
).
withParameterOfType
(
""myType""
,
""parameterName""
,
object
);
When using withParameterOfType, the mocking framework needs to know how to compare the type and therefore a Comparator has to be installed before using parameters of this type. This is done using installComparator, as below:
MyTypeComparator
comparator
;
mock
().
installComparator
(
""myType""
,
comparator
);
MyTypeComparator is a custom comparator, which implements the MockNamedValueComparator interface. For example:
class
MyTypeComparator
:
public
MockNamedValueComparator
{
public:
virtual
bool
isEqual
(
const
void
*
object1
,
const
void
*
object2
)
{
return
object1
==
object2
;
}
virtual
SimpleString
valueToString
(
const
void
*
object
)
{
return
StringFrom
(
object
);
}
};
The isEqual is called to compare the two parameters. The valueToString is called when an error message is printed and it needs to print the actual and expected values. If you want to use normal C functions, you can use the MockFunctionComparator which accepts pointers to functions in the constructor.
To remove the comparators, all you needs to do is call removeAllComparatorsAndCopiers, like:
mock
().
removeAllComparatorsAndCopiers
();
Comparators sometimes lead to surprises, so a couple of warnings on its usage:
Warning 1:
Pay attention to the scope of your comparator variable!
Comparators are
not
copied, instead it uses the exact instance as passed to the installComparator function. So make sure it is still in-scope when the framework tries to use it! For example, if you installComparator inside the TEST, but do the checkExpectations in the teardown, then it is likely to cause a crash since the comparator has been destroyed.
Warning 2:
Pay extra attention to scope when using the MockPlugin
When using the MockPlugin (recommended), then it’s best to install the comparators via the MockPlugin or put them in global space. The checkExpectations will be called
after
teardown and if your comparator was destroyed in the teardown then this will cause a crash.
Output Parameters
Some parameters do not represent data passed to the called function, but are passed by reference so that the function can ‘return’ a value by modifying the pointed-to data.
CppUMock allows the value of these output parameters to be specified in the expected call:
int
outputValue
=
4
;
mock
().
expectOneCall
(
""Foo""
).
withOutputParameterReturning
(
""bar""
,
&
outputValue
,
sizeof
(
outputValue
));
…and written during the actual call:
void
Foo
(
int
*
bar
)
{
mock
().
actualCall
(
""Foo""
).
withOutputParameter
(
""bar""
,
bar
);
}
After the actual call, the bar parameter passed to function Foo will have the value specified in the expected call (4, in this case).
Warning 1:
CppUMock
does not
and
cannot
prevent invalid memory accesses when using output parameters. It will memcpy exactly the number of bytes specified in the withOutputParameterReturning call. A segmentation fault may occur if this is larger than the data pointed to by the output parameter provided in the actual call.
Warning 2:
When a char, int, etc. array is passed to withOutputParameter, you must use the generic withOutputParameterReturning and provide the actual size of the array or only one element will be copied.
Output Parameters Using Objects
By far the best way to handle output parameters is by using a custom type copier (v3.8). The general principle is similar to the custom comparators described above:
MyType
outputValue
=
4
;
mock
().
expectOneCall
(
""Foo""
).
withOutputParameterOfTypeReturning
(
""MyType""
,
""bar""
,
&
outputValue
);
The corresponding actual call is:
void
Foo
(
MyType
*
bar
)
{
mock
().
actualCall
(
""Foo""
).
withOutputParameterOfType
(
""MyType""
,
""bar""
,
bar
);
}
When using withOutputParameterOfTypeReturning, the mocking framework needs to know how to copy the type and therefore a Copier has to be installed before using parameters of this type. This is done using installCopier, as below:
MyTypeCopier
copier
;
mock
().
installCopier
(
""myType""
,
copier
);
MyTypeCopier is a custom copier, which implements the MockNamedValueCopier interface. For example:
class
MyTypeCopier
:
public
MockNamedValueCopier
{
public:
virtual
void
copy
(
void
*
out
,
const
void
*
in
)
{
*
(
MyType
*
)
out
=
*
(
const
MyType
*
)
in
;
}
};
To remove the copier, you need to call removeAllComparatorsAndCopiers, like:
mock
().
removeAllComparatorsAndCopiers
();
Warning 1
and
Warning 2
above apply to copiers as well.
Return Values
Sometimes it is needed to let a mock function return a value which can then be used in production code. The test code would look like this:
mock
().
expectOneCall
(
""function""
).
andReturnValue
(
10
);
The mock function would look like:
int
function
()
{
return
mock
().
actualCall
(
""function""
).
returnIntValue
();
}
or we could separate returnIntValue from the actualCall (below it!) like:
int
function
()
{
mock
().
actualCall
(
""function""
);
return
mock
().
intReturnValue
();
}
The return value options are used to transfer data between the test and the mock object, they themselves do not cause the tests to fail.
Passing other data
Sometimes a test wants to pass more data to the mock object to, for example, vary only a couple of parameters in a calculation. This can be done like this:
ClassFromProductionCode
object
;
mock
().
setData
(
""importantValue""
,
10
);
mock
().
setDataObject
(
""importantObject""
,
""ClassFromProductionCode""
,
&
object
);
And it can be used in the mock object like:
ClassFromProductionCode
*
pobject
;
int
value
=
mock
().
getData
(
""importantValue""
).
getIntValue
();
pobject
=
(
ClassFromProductionCode
*
)
mock
().
getData
(
""importantObject""
).
getObjectPointer
();
Like return values, setting data will not ever make a test fail but it provides support in building mock objects.
Other MockSupport - ignoring, enabling, clearing, crashing
MockSupport offers a couple of other useful functions, which will be covered in this section.
Frequently, you only want to check a couple of calls in your test and ignore all the other calls. If you add expectOneCall for each of these calls, your tests might become too large (though, it might be a smell that your test is indeed too large). One way to prevent this is the ignoreOtherCalls, like:
mock
().
expectOneCall
(
""foo""
);
mock
().
ignoreOtherCalls
();
This will check that one call of foo happens (and only one call!), but all other calls will be ignored (such as “bar”).
Sometimes, you don’t want to just ignore calls, but instead disable the whole mocking framework for a while (to do
something
). This happens sometimes in initialization where you might want to do
something
without the mocking framework checking calls. You can do this by enabling/disabling such as:
mock
().
disable
();
doSomethingThatWouldOtherwiseBlowUpTheMockingFramework
();
mock
().
enable
();
When you are ignoring calls to mocked functions that have a return value there is a catch. You will probably get a runtime error on your test when you try to ignore it.
As almost all things in life it is easier to explain this with an example, lets say you have this mock function:
int
function
()
{
return
mock
().
actualCall
(
""function""
).
returnIntValue
();
}
If you try to ignore it or disable the framework, it will explode. Why ? The return value is not defined so there is no way to define the return value of the mocked function.
To cases like these there is a series of return value functions that allows you to define a default return value that will be returned when the mock function is ignored.
The example above could be written as:
int
function
()
{
return
mock
().
actualCall
(
""function""
).
returnIntValueOrDefault
(
5
);
}
If the function is ignored or the framework is disabled, a 5 will be returned, otherwise the expected return value will be returned (according to the expectations set on the test case).
You can also use mock support directly to do this (instead of using the actual call object):
int
function
()
{
mock
().
actualCall
(
""function""
);
return
mock
().
returnIntValueOrDefault
(
5
);
}
If you want to clear all the expectations, settings, and comparators, call clear:
mock
().
clear
();
Clear won’t do checkExpectations, but just erase everything and start over. Usually clear() is called after a checkExpectations.
Sometimes, a mock actual call happens, but you cannot figure out from where it is called. If you only had a call stack, then it you could track it. Well, unfortunately, the mocking framework doesn’t print stack traces, but it can crash! If you call the crashOnFailure on the MockSupport, then it will crash so that you can use the debugger to get a stack trace. like:
mock
().
crashOnFailure
();
When using gdb, get a stack trace using:
gdb examples/CppUTestExamples_tests
r
bt
(r is run, it will run until crashes. bt is back trace which will produce a stack)
MockSupport Scope
MockSupport can be used hierarchically using MockSupport scope. This sounds really complex, but in reality it is very simple. When getting a mock support using the mock function, you can pass a namespace or scope and record the expectations (or do other things) inside this scope. For example:
mock
(
""xmlparser""
).
expectOneCall
(
""open""
);
The actual call then has to look like this:
mock
(
""xmlparser""
).
actualCall
(
""open""
);
A call on another namespace won’t work, for example this won’t match the call to xmlparser open:
mock
(
""""
).
actualCall
(
""open""
);
Keeping calls in namespaces makes it easy to ignore one type of call and focus on another, for example:
mock
(
""xmlparser""
).
expectOneCall
(
""open""
);
mock
(
""filesystem""
).
ignoreOtherCalls
();
MockSupportPlugin
There is a MockSupportPlugin to make the work with mocks easier. Complete Documentation for MockSupportPlugin can be found on the
Plugin Manual
page.
C Interface
Sometimes it is useful to access the mocking framework from a .c file rather than a .cpp file. For example, perhaps, for some reason, the stubs are implemented in a .c file rather than a .cpp file. Instead of changing over all to .cpp, it would be easier if the mocking framework can be called via C. The C interface is exactly meant for this. The interface is based on the C++ one, so below is some code and it ought to be easy to figure out what it does (if you’ve read all that was written earlier):
#include ""CppUTestExt/MockSupport_c.h""
mock_c
()
->
expectOneCall
(
""foo""
)
->
withIntParameters
(
""integer""
,
10
)
->
andReturnDoubleValue
(
1.11
);
return
mock_c
()
->
actualCall
(
""foo""
)
->
withIntParameters
(
""integer""
,
10
)
->
returnValue
().
value
.
doubleValue
;
mock_c
()
->
installComparator
(
""type""
,
equalMethod
,
toStringMethod
);
mock_scope_c
(
""scope""
)
->
expectOneCall
(
""bar""
)
->
withParameterOfType
(
""type""
,
""name""
,
object
);
mock_scope_c
(
""scope""
)
->
actualCall
(
""bar""
)
->
withParameterOfType
(
""type""
,
""name""
,
object
);
mock_c
()
->
removeAllComparators
();
mock_c
()
->
setIntData
(
""important""
,
10
);
mock_c
()
->
checkExpectations
();
mock_c
()
->
clear
();
The C interface uses a similar builder structure as the C++ interface. It is far less common in C, but it works the same.
It is now also possible to specify the actual return value in the same way as with C++ (v3.8):
return
mock_c
()
->
actualCall
(
""foo""
)
->
withIntParameters
(
""integer""
,
10
)
->
doubleReturnValue
();
return
mock_c
()
->
doubleReturnValue
();
and to specify a default return value, in case mocking is currently disabled when the actual call occurs (v3.8):
return
mock_c
()
->
actualCall
(
""foo""
)
->
withIntParameters
(
""integer""
,
10
)
->
returnDoubleValueOrDefault
(
2.25
);
return
mock_c
()
->
returnDoubleValueOrDefault
(
2.25
);
Miscellaneous
If you want your test to be more explicit about that a certain mocked function call should not occur, you can write (v3.8):
mock
().
expectNoCall
(
""productionCode""
);
Doing so is functionally equivalent to stating no expectations at all.

cpputest
/
cpputest
Public
Notifications
You must be signed in to change notification settings
Fork
516
Star
1.4k
Code
Issues
168
Pull requests
19
Discussions
Actions
Projects
0
Security
Insights
Additional navigation options
Code
Issues
Pull requests
Discussions
Actions
Projects
Security
Insights
Files
master
Breadcrumbs
cpputest
/
tests
/
CppUTest
/
SimpleStringTest.cpp
Blame
Blame
Latest commit
History
History
1277 lines (1062 loc) · 35.5 KB
master
Breadcrumbs
cpputest
/
tests
/
CppUTest
/
SimpleStringTest.cpp
Top
File metadata and controls
Code
Blame
1277 lines (1062 loc) · 35.5 KB
Raw
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
812
813
814
815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
837
838
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870
871
872
873
874
875
876
877
878
879
880
881
882
883
884
885
886
887
888
889
890
891
892
893
894
895
896
897
898
899
900
901
902
903
904
905
906
907
908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923
924
925
926
927
928
929
930
931
932
933
934
935
936
937
938
939
940
941
942
943
944
945
946
947
948
949
950
951
952
953
954
955
956
957
958
959
960
961
962
963
964
965
966
967
968
969
970
971
972
973
974
975
976
977
978
979
980
981
982
983
984
985
986
987
988
989
990
991
992
993
994
995
996
997
998
999
1000
/*
* Copyright (c) 2007, Michael Feathers, James Grenning and Bas Vodde
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the <organization> nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE EARLIER MENTIONED AUTHORS ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL <copyright holder> BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#
include
""
CppUTest/TestHarness.h
""
#
include
""
CppUTest/SimpleString.h
""
#
include
""
CppUTest/PlatformSpecificFunctions.h
""
#
include
""
CppUTest/TestMemoryAllocator.h
""
#
include
""
CppUTest/MemoryLeakDetector.h
""
#
include
""
CppUTest/TestTestingFixture.h
""
class
JustUseNewStringAllocator
:
public
TestMemoryAllocator
{
public:
virtual
~JustUseNewStringAllocator
() CPPUTEST_DESTRUCTOR_OVERRIDE {}
char
*
alloc_memory
(
size_t
size,
const
char
* file,
size_t
line) CPPUTEST_OVERRIDE
{
return
MemoryLeakWarningPlugin::getGlobalDetector
()->
allocMemory
(
getCurrentNewArrayAllocator
(), size, file, line);
}
void
free_memory
(
char
* str,
size_t
,
const
char
* file,
size_t
line) CPPUTEST_OVERRIDE
{
MemoryLeakWarningPlugin::getGlobalDetector
()->
deallocMemory
(
getCurrentNewArrayAllocator
(), str, file, line);
}
};
class
GlobalSimpleStringMemoryAccountantExecFunction
: public ExecFunction
{
public:
void
(*testFunction_)(GlobalSimpleStringMemoryAccountant*);
GlobalSimpleStringMemoryAccountant* parameter_;
virtual
void
exec
() CPPUTEST_OVERRIDE
{
testFunction_
(parameter_);
}
};
TEST_GROUP
(GlobalSimpleStringMemoryAccountant)
{
GlobalSimpleStringAllocatorStash stash;
GlobalSimpleStringMemoryAccountantExecFunction testFunction;
TestTestingFixture fixture;
GlobalSimpleStringMemoryAccountant accountant;
void
setup
() CPPUTEST_OVERRIDE
{
stash.
save
();
testFunction.
parameter_
= &accountant;
fixture.
setTestFunction
(&testFunction);
}
void
teardown
() CPPUTEST_OVERRIDE
{
stash.
restore
();
}
};
TEST
(GlobalSimpleStringMemoryAccountant, start)
{
accountant.
start
();
POINTERS_EQUAL
(accountant.
getAllocator
(),
SimpleString::getStringAllocator
());
}
TEST
(GlobalSimpleStringMemoryAccountant, startTwiceDoesNothing)
{
accountant.
start
();
TestMemoryAllocator* memoryAccountantAllocator =
SimpleString::getStringAllocator
();
accountant.
start
();
POINTERS_EQUAL
(memoryAccountantAllocator,
SimpleString::getStringAllocator
());
accountant.
stop
();
}
TEST
(GlobalSimpleStringMemoryAccountant, stop)
{
TestMemoryAllocator* originalAllocator =
SimpleString::getStringAllocator
();
accountant.
start
();
accountant.
stop
();
POINTERS_EQUAL
(originalAllocator,
SimpleString::getStringAllocator
());
}
static
void
stopAccountant_
(GlobalSimpleStringMemoryAccountant* accountant)
{
accountant->
stop
();
}
TEST
(GlobalSimpleStringMemoryAccountant, stopWithoutStartWillFail)
{
testFunction.
testFunction_
= stopAccountant_;
fixture.
runAllTests
();
fixture.
assertPrintContains
(
""
Global SimpleString allocator stopped without starting
""
);
}
static
void
changeAllocatorBetweenStartAndStop_
(GlobalSimpleStringMemoryAccountant* accountant)
{
TestMemoryAllocator* originalAllocator =
SimpleString::getStringAllocator
();
accountant->
start
();
SimpleString::setStringAllocator
(originalAllocator);
accountant->
stop
();
}
TEST
(GlobalSimpleStringMemoryAccountant, stopFailsWhenAllocatorWasChangedInBetween)
{
testFunction.
testFunction_
= changeAllocatorBetweenStartAndStop_;
fixture.
runAllTests
();
fixture.
assertPrintContains
(
""
GlobalStrimpleStringMemoryAccountant: allocator has changed between start and stop!
""
);
}
TEST
(GlobalSimpleStringMemoryAccountant, report)
{
SimpleString str;
accountant.
start
();
str +=
""
More
""
;
accountant.
stop
();
STRCMP_CONTAINS
(
""
1                0                 1
""
, accountant.
report
().
asCharString
());
}
TEST
(GlobalSimpleStringMemoryAccountant, reportUseCaches)
{
size_t
caches[] = {
32
};
accountant.
useCacheSizes
(caches,
1
);
SimpleString str;
accountant.
start
();
str +=
""
More
""
;
accountant.
stop
();
STRCMP_CONTAINS
(
""
32                   1                1                 1
""
, accountant.
report
().
asCharString
());
}
TEST_GROUP
(SimpleString)
{
JustUseNewStringAllocator justNewForSimpleStringTestAllocator;
GlobalSimpleStringAllocatorStash stash;
void
setup
() CPPUTEST_OVERRIDE
{
stash.
save
();
SimpleString::setStringAllocator
(&justNewForSimpleStringTestAllocator);
}
void
teardown
() CPPUTEST_OVERRIDE
{
stash.
restore
();
}
};
TEST
(SimpleString, defaultAllocatorIsNewArrayAllocator)
{
SimpleString::setStringAllocator
(NULLPTR);
POINTERS_EQUAL
(
defaultNewArrayAllocator
(),
SimpleString::getStringAllocator
());
}
class
MyOwnStringAllocator
:
public
TestMemoryAllocator
{
public:
MyOwnStringAllocator
() : memoryWasAllocated(
false
) {}
virtual
~MyOwnStringAllocator
() CPPUTEST_DESTRUCTOR_OVERRIDE {}
bool
memoryWasAllocated;
char
*
alloc_memory
(
size_t
size,
const
char
* file,
size_t
line) CPPUTEST_OVERRIDE
{
memoryWasAllocated =
true
;
return
TestMemoryAllocator::alloc_memory
(size, file, line);
}
};
TEST
(SimpleString, allocatorForSimpleStringCanBeReplaced)
{
MyOwnStringAllocator myOwnAllocator;
SimpleString::setStringAllocator
(&myOwnAllocator);
SimpleString simpleString;
CHECK
(myOwnAllocator.
memoryWasAllocated
);
SimpleString::setStringAllocator
(NULLPTR);
}
TEST
(SimpleString, CreateSequence)
{
SimpleString
expected
(
""
hellohello
""
);
SimpleString
actual
(
""
hello
""
,
2
);
CHECK_EQUAL
(expected, actual);
}
TEST
(SimpleString, CreateSequenceOfZero)
{
SimpleString
expected
(
""
""
);
SimpleString
actual
(
""
hello
""
,
0
);
CHECK_EQUAL
(expected, actual);
}
TEST
(SimpleString, Copy)
{
SimpleString
s1
(
""
hello
""
);
SimpleString
s2
(s1);
CHECK_EQUAL
(s1, s2);
}
TEST
(SimpleString, Assignment)
{
SimpleString
s1
(
""
hello
""
);
SimpleString
s2
(
""
goodbye
""
);
s2 = s1;
CHECK_EQUAL
(s1, s2);
}
TEST
(SimpleString, Equality)
{
SimpleString
s1
(
""
hello
""
);
SimpleString
s2
(
""
hello
""
);
CHECK
(s1 == s2);
}
TEST
(SimpleString, InEquality)
{
SimpleString
s1
(
""
hello
""
);
SimpleString
s2
(
""
goodbye
""
);
CHECK
(s1 != s2);
}
TEST
(SimpleString, CompareNoCaseWithoutCase)
{
SimpleString
s1
(
""
hello
""
);
SimpleString
s2
(
""
hello
""
);
CHECK
(s1.
equalsNoCase
(s2));
}
TEST
(SimpleString, CompareNoCaseWithCase)
{
SimpleString
s1
(
""
hello
""
);
SimpleString
s2
(
""
HELLO
""
);
CHECK
(s1.
equalsNoCase
(s2));
}
TEST
(SimpleString, CompareNoCaseWithCaseNotEqual)
{
SimpleString
s1
(
""
hello
""
);
SimpleString
s2
(
""
WORLD
""
);
CHECK
(!s1.
equalsNoCase
(s2));
}
TEST
(SimpleString, asCharString)
{
SimpleString
s1
(
""
hello
""
);
STRCMP_EQUAL
(
""
hello
""
, s1.
asCharString
());
}
TEST
(SimpleString,
Size
)
{
SimpleString
s1
(
""
hello!
""
);
LONGS_EQUAL
(
6
, s1.
size
());
}
TEST
(SimpleString, lowerCase)
{
SimpleString
s1
(
""
AbCdEfG1234
""
);
SimpleString
s2
(s1.
lowerCase
());
STRCMP_EQUAL
(
""
abcdefg1234
""
, s2.
asCharString
());
STRCMP_EQUAL
(
""
AbCdEfG1234
""
, s1.
asCharString
());
}
TEST
(SimpleString, printable)
{
SimpleString
s1
(
""
ABC
\01\06\a\n\r\b\t\v\f\x0E\x1F\x7F
""
""
abc
""
);
SimpleString
s2
(s1.
printable
());
STRCMP_EQUAL
(
""
ABC
\\
x01
\\
x06
\\
a
\\
n
\\
r
\\
b
\\
t
\\
v
\\
f
\\
x0E
\\
x1F
\\
x7Fabc
""
, s2.
asCharString
());
STRCMP_EQUAL
(
""
ABC
\01\06\a\n\r\b\t\v\f\x0E\x1F\x7F
""
""
abc
""
, s1.
asCharString
());
}
TEST
(SimpleString, Addition)
{
SimpleString
s1
(
""
hello!
""
);
SimpleString
s2
(
""
goodbye!
""
);
SimpleString
s3
(
""
hello!goodbye!
""
);
SimpleString s4;
s4 = s1 + s2;
CHECK_EQUAL
(s3, s4);
}
TEST
(SimpleString, Concatenation)
{
SimpleString
s1
(
""
hello!
""
);
SimpleString
s2
(
""
goodbye!
""
);
SimpleString
s3
(
""
hello!goodbye!
""
);
SimpleString s4;
s4 += s1;
s4 += s2;
CHECK_EQUAL
(s3, s4);
SimpleString
s5
(
""
hello!goodbye!hello!goodbye!
""
);
s4 += s4;
CHECK_EQUAL
(s5, s4);
}
TEST
(SimpleString, Contains)
{
SimpleString
s
(
""
hello!
""
);
SimpleString
empty
(
""
""
);
SimpleString
beginning
(
""
hello
""
);
SimpleString
end
(
""
lo!
""
);
SimpleString
mid
(
""
l
""
);
SimpleString
notPartOfString
(
""
xxxx
""
);
CHECK
(s.
contains
(empty));
CHECK
(s.
contains
(beginning));
CHECK
(s.
contains
(end));
CHECK
(s.
contains
(mid));
CHECK
(!s.
contains
(notPartOfString));
CHECK
(empty.
contains
(empty));
CHECK
(!empty.
contains
(s));
}
TEST
(SimpleString, startsWith)
{
SimpleString
hi
(
""
Hi you!
""
);
SimpleString
part
(
""
Hi
""
);
SimpleString
diff
(
""
Hrrm Hi you! ffdsfd
""
);
CHECK
(hi.
startsWith
(part));
CHECK
(!part.
startsWith
(hi));
CHECK
(!diff.
startsWith
(hi));
}
TEST
(SimpleString, split)
{
SimpleString
hi
(
""
hello
\n
world
\n
how
\n
do
\n
you
\n
do
\n\n
""
);
SimpleStringCollection collection;
hi.
split
(
""
\n
""
, collection);
LONGS_EQUAL
(
7
, collection.
size
());
STRCMP_EQUAL
(
""
hello
\n
""
, collection[
0
].
asCharString
());
STRCMP_EQUAL
(
""
world
\n
""
, collection[
1
].
asCharString
());
STRCMP_EQUAL
(
""
how
\n
""
, collection[
2
].
asCharString
());
STRCMP_EQUAL
(
""
do
\n
""
, collection[
3
].
asCharString
());
STRCMP_EQUAL
(
""
you
\n
""
, collection[
4
].
asCharString
());
STRCMP_EQUAL
(
""
do
\n
""
, collection[
5
].
asCharString
());
STRCMP_EQUAL
(
""
\n
""
, collection[
6
].
asCharString
());
}
TEST
(SimpleString, splitNoTokenOnTheEnd)
{
SimpleString
string
(
""
Bah Yah oops
""
);
SimpleStringCollection collection;
string.
split
(
""
""
, collection);
LONGS_EQUAL
(
3
, collection.
size
());
STRCMP_EQUAL
(
""
Bah
""
, collection[
0
].
asCharString
());
STRCMP_EQUAL
(
""
Yah
""
, collection[
1
].
asCharString
());
STRCMP_EQUAL
(
""
oops
""
, collection[
2
].
asCharString
());
}
TEST
(SimpleString, count)
{
SimpleString
str
(
""
ha ha ha ha
""
);
LONGS_EQUAL
(
4
, str.
count
(
""
ha
""
));
}
TEST
(SimpleString, countTogether)
{
SimpleString
str
(
""
hahahaha
""
);
LONGS_EQUAL
(
4
, str.
count
(
""
ha
""
));
}
TEST
(SimpleString, countEmptyString)
{
SimpleString
str
(
""
hahahaha
""
);
LONGS_EQUAL
(
8
, str.
count
(
""
""
));
}
TEST
(SimpleString, countEmptyStringInEmptyString)
{
SimpleString str;
LONGS_EQUAL
(
0
, str.
count
(
""
""
));
}
TEST
(SimpleString, endsWith)
{
SimpleString
str
(
""
Hello World
""
);
CHECK
(str.
endsWith
(
""
World
""
));
CHECK
(!str.
endsWith
(
""
Worl
""
));
CHECK
(!str.
endsWith
(
""
Hello
""
));
SimpleString
str2
(
""
ah
""
);
CHECK
(str2.
endsWith
(
""
ah
""
));
CHECK
(!str2.
endsWith
(
""
baah
""
));
SimpleString
str3
(
""
""
);
CHECK
(!str3.
endsWith
(
""
baah
""
));
SimpleString
str4
(
""
ha ha ha ha
""
);
CHECK
(str4.
endsWith
(
""
ha
""
));
}
TEST
(SimpleString, replaceCharWithChar)
{
SimpleString
str
(
""
abcabcabca
""
);
str.
replace
(
'
a
'
,
'
b
'
);
STRCMP_EQUAL
(
""
bbcbbcbbcb
""
, str.
asCharString
());
}
TEST
(SimpleString, replaceEmptyStringWithEmptyString)
{
SimpleString str;
str.
replace
(
""
""
,
""
""
);
STRCMP_EQUAL
(
""
""
, str.
asCharString
());
}
TEST
(SimpleString, replaceWholeString)
{
SimpleString
str
(
""
boo
""
);
str.
replace
(
""
boo
""
,
""
""
);
STRCMP_EQUAL
(
""
""
, str.
asCharString
());
}
TEST
(SimpleString, replaceStringWithString)
{
SimpleString
str
(
""
boo baa boo baa boo
""
);
str.
replace
(
""
boo
""
,
""
boohoo
""
);
STRCMP_EQUAL
(
""
boohoo baa boohoo baa boohoo
""
, str.
asCharString
());
}
TEST
(SimpleString, subStringFromEmptyString)
{
SimpleString
str
(
""
""
);
STRCMP_EQUAL
(
""
""
, str.
subString
(
0
,
1
).
asCharString
());
}
TEST
(SimpleString, subStringFromSmallString)
{
SimpleString
str
(
""
H
""
);
STRCMP_EQUAL
(
""
H
""
, str.
subString
(
0
,
1
).
asCharString
());
}
TEST
(SimpleString, subStringFromPos0)
{
SimpleString
str
(
""
Hello World
""
);
STRCMP_EQUAL
(
""
Hello
""
, str.
subString
(
0
,
5
).
asCharString
());
}
TEST
(SimpleString, subStringFromPos1)
{
SimpleString
str
(
""
Hello World
""
);
STRCMP_EQUAL
(
""
ello
""
, str.
subString
(
1
,
5
).
asCharString
());
}
TEST
(SimpleString, subStringFromPos5WithAmountLargerThanString)
{
SimpleString
str
(
""
Hello World
""
);
STRCMP_EQUAL
(
""
World
""
, str.
subString
(
6
,
10
).
asCharString
());
}
TEST
(SimpleString, subStringFromPos6ToEndOfString)
{
SimpleString
str
(
""
Hello World
""
);
STRCMP_EQUAL
(
""
World
""
, str.
subString
(
6
).
asCharString
());
}
TEST
(SimpleString, subStringBeginPosOutOfBounds)
{
SimpleString
str
(
""
Hello World
""
);
STRCMP_EQUAL
(
""
""
, str.
subString
(
13
,
5
).
asCharString
());
}
TEST
(SimpleString, subStringFromTillNormal)
{
SimpleString
str
(
""
Hello World
""
);
STRCMP_EQUAL
(
""
Hello
""
, str.
subStringFromTill
(
'
H
'
,
'
'
).
asCharString
());
}
TEST
(SimpleString, subStringFromTillOutOfBounds)
{
SimpleString
str
(
""
Hello World
""
);
STRCMP_EQUAL
(
""
World
""
, str.
subStringFromTill
(
'
W
'
,
'
!
'
).
asCharString
());
}
TEST
(SimpleString, subStringFromTillStartDoesntExist)
{
SimpleString
str
(
""
Hello World
""
);
STRCMP_EQUAL
(
""
""
, str.
subStringFromTill
(
'
!
'
,
'
'
).
asCharString
());
}
TEST
(SimpleString, subStringFromTillWhenTheEndAppearsBeforeTheStart)
{
SimpleString
str
(
""
Hello World
""
);
STRCMP_EQUAL
(
""
World
""
, str.
subStringFromTill
(
'
W
'
,
'
H
'
).
asCharString
());
}
TEST
(SimpleString, findNormal)
{
SimpleString
str
(
""
Hello World
""
);
LONGS_EQUAL
(
0
, str.
find
(
'
H
'
));
LONGS_EQUAL
(
1
, str.
find
(
'
e
'
));
LONGS_EQUAL
(SimpleString::npos, str.
find
(
'
!
'
));
}
TEST
(SimpleString, at)
{
SimpleString
str
(
""
Hello World
""
);
BYTES_EQUAL
(
'
H
'
, str.
at
(
0
));
}
TEST
(SimpleString, copyInBufferNormal)
{
SimpleString
str
(
""
Hello World
""
);
size_t
bufferSize = str.
size
()+
1
;
char
* buffer = (
char
*)
PlatformSpecificMalloc
(bufferSize);
str.
copyToBuffer
(buffer, bufferSize);
STRCMP_EQUAL
(str.
asCharString
(), buffer);
PlatformSpecificFree
(buffer);
}
TEST
(SimpleString, copyInBufferWithEmptyBuffer)
{
SimpleString
str
(
""
Hello World
""
);
char
* buffer= NULLPTR;
str.
copyToBuffer
(buffer,
0
);
POINTERS_EQUAL
(NULLPTR, buffer);
}
TEST
(SimpleString, copyInBufferWithBiggerBufferThanNeeded)
{
SimpleString
str
(
""
Hello
""
);
size_t
bufferSize =
20
;
char
* buffer= (
char
*)
PlatformSpecificMalloc
(bufferSize);
str.
copyToBuffer
(buffer, bufferSize);
STRCMP_EQUAL
(str.
asCharString
(), buffer);
PlatformSpecificFree
(buffer);
}
TEST
(SimpleString, copyInBufferWithSmallerBufferThanNeeded)
{
SimpleString
str
(
""
Hello
""
);
size_t
bufferSize = str.
size
();
char
* buffer= (
char
*)
PlatformSpecificMalloc
(bufferSize);
str.
copyToBuffer
(buffer, bufferSize);
STRNCMP_EQUAL
(str.
asCharString
(), buffer, (bufferSize-
1
));
LONGS_EQUAL
(
0
, buffer[bufferSize-
1
]);
PlatformSpecificFree
(buffer);
}
TEST
(SimpleString, ContainsNull)
{
SimpleString
s
(NULLPTR);
STRCMP_EQUAL
(
""
""
, s.
asCharString
());
}
TEST
(SimpleString, NULLReportsNullString)
{
STRCMP_EQUAL
(
""
(null)
""
,
StringFromOrNull
((
char
*) NULLPTR).
asCharString
());
}
TEST
(SimpleString, NULLReportsNullStringPrintable)
{
STRCMP_EQUAL
(
""
(null)
""
,
PrintableStringFromOrNull
((
char
*) NULLPTR).
asCharString
());
}
TEST
(SimpleString, Booleans)
{
SimpleString
s1
(
StringFrom
(
true
));
SimpleString
s2
(
StringFrom
(
false
));
CHECK
(s1 ==
""
true
""
);
CHECK
(s2 ==
""
false
""
);
}
TEST
(SimpleString, Pointers)
{
SimpleString
s
(
StringFrom
((
void
*)
0x1234
));
STRCMP_EQUAL
(
""
0x1234
""
, s.
asCharString
());
}
TEST
(SimpleString, FunctionPointers)
{
SimpleString
s
(
StringFrom
((
void
(*)())
0x1234
));
STRCMP_EQUAL
(
""
0x1234
""
, s.
asCharString
());
}
TEST
(SimpleString, Characters)
{
SimpleString
s
(
StringFrom
(
'
a
'
));
STRCMP_EQUAL
(
""
a
""
, s.
asCharString
());
}
TEST
(SimpleString, NegativeSignedBytes)
{
STRCMP_EQUAL
(
""
-15
""
,
StringFrom
((
signed
char
)-
15
).
asCharString
());
}
TEST
(SimpleString, PositiveSignedBytes)
{
STRCMP_EQUAL
(
""
4
""
,
StringFrom
(
4
).
asCharString
());
}
TEST
(SimpleString, LongInts)
{
SimpleString
s
(
StringFrom
((
long
)
1
));
CHECK
(s ==
""
1
""
);
}
TEST
(SimpleString, UnsignedLongInts)
{
SimpleString
s
(
StringFrom
((
unsigned
long
)
1
));
SimpleString
s2
(
StringFrom
((
unsigned
long
)
1
));
CHECK
(s == s2);
}
#
if
CPPUTEST_USE_LONG_LONG
TEST
(SimpleString, LongLongInts)
{
SimpleString
s
(
StringFrom
((
long
long
)
1
));
CHECK
(s ==
""
1
""
);
}
TEST
(SimpleString, UnsignedLongLongInts)
{
SimpleString
s
(
StringFrom
((
unsigned
long
long
)
1
));
SimpleString
s2
(
StringFrom
((
unsigned
long
long
)
1
));
CHECK
(s == s2);
}
#
endif
/*
CPPUTEST_USE_LONG_LONG
*/
TEST
(SimpleString, Doubles)
{
SimpleString
s
(
StringFrom
(
1.2
));
STRCMP_EQUAL
(
""
1.2
""
, s.
asCharString
());
}
extern
""
C
""
{
static
int
alwaysTrue
(
double
) {
return
true
; }
}
TEST
(SimpleString, NaN)
{
UT_PTR_SET
(PlatformSpecificIsNan, alwaysTrue);
SimpleString
s
(
StringFrom
(
0.0
));
STRCMP_EQUAL
(
""
Nan - Not a number
""
, s.
asCharString
());
}
TEST
(SimpleString, Inf)
{
UT_PTR_SET
(PlatformSpecificIsInf, alwaysTrue);
SimpleString
s
(
StringFrom
(
0.0
));
STRCMP_EQUAL
(
""
Inf - Infinity
""
, s.
asCharString
());
}
TEST
(SimpleString, SmallDoubles)
{
SimpleString
s
(
StringFrom
(
1.2e-10
));
STRCMP_CONTAINS
(
""
1.2e
""
, s.
asCharString
());
}
TEST
(SimpleString, Sizes)
{
size_t
size =
10
;
STRCMP_EQUAL
(
""
10
""
,
StringFrom
((
int
) size).
asCharString
());
}
#
if
__cplusplus > 199711L && !defined __arm__ && CPPUTEST_USE_STD_CPP_LIB
TEST
(SimpleString, nullptr_type)
{
SimpleString
s
(
StringFrom
(NULLPTR));
STRCMP_EQUAL
(
""
(null)
""
, s.
asCharString
());
}
#
endif
TEST
(SimpleString, HexStrings)
{
STRCMP_EQUAL
(
""
f3
""
,
HexStringFrom
((
signed
char
)-
13
).
asCharString
());
SimpleString h1 =
HexStringFrom
(
0xffffL
);
STRCMP_EQUAL
(
""
ffff
""
, h1.
asCharString
());
#
if
CPPUTEST_USE_LONG_LONG
SimpleString h15 =
HexStringFrom
(
0xffffLL
);
STRCMP_EQUAL
(
""
ffff
""
, h15.
asCharString
());
#
endif
SimpleString h2 =
HexStringFrom
((
void
*)
0xfffeL
);
STRCMP_EQUAL
(
""
fffe
""
, h2.
asCharString
());
SimpleString h3 =
HexStringFrom
((
void
(*)())
0xfffdL
);
STRCMP_EQUAL
(
""
fffd
""
, h3.
asCharString
());
}
TEST
(SimpleString, StringFromFormat)
{
SimpleString h1 =
StringFromFormat
(
""
%s %s! %d
""
,
""
Hello
""
,
""
World
""
,
2009
);
STRCMP_EQUAL
(
""
Hello World! 2009
""
, h1.
asCharString
());
}
TEST
(SimpleString, StringFromFormatpointer)
{
//
this is not a great test. but %p is odd on mingw and even more odd on Solaris.
SimpleString h1 =
StringFromFormat
(
""
%p
""
, (
void
*)
1
);
if
(h1.
size
() ==
3
)
STRCMP_EQUAL
(
""
0x1
""
, h1.
asCharString
());
else
if
(h1.
size
() ==
8
)
STRCMP_EQUAL
(
""
00000001
""
, h1.
asCharString
());
else
if
(h1.
size
() ==
9
)
STRCMP_EQUAL
(
""
0000:0001
""
, h1.
asCharString
());
else
if
(h1.
size
() ==
16
)
STRCMP_EQUAL
(
""
0000000000000001
""
, h1.
asCharString
());
else
if
(h1.
size
() ==
1
)
STRCMP_EQUAL
(
""
1
""
, h1.
asCharString
());
else
FAIL
(
""
Off %p behavior
""
);
}
TEST
(SimpleString, StringFromFormatLarge)
{
const
char
* s =
""
ThisIsAPrettyLargeStringAndIfWeAddThisManyTimesToABufferItWillbeFull
""
;
SimpleString h1 =
StringFromFormat
(
""
%s%s%s%s%s%s%s%s%s%s
""
, s, s, s, s, s, s, s, s, s, s);
LONGS_EQUAL
(
10
, h1.
count
(s));
}
TEST
(SimpleString, StringFromConstSimpleString)
{
STRCMP_EQUAL
(
""
bla
""
,
StringFrom
(
SimpleString
(
""
bla
""
)).
asCharString
());
}
static
int
WrappedUpVSNPrintf
(
char
* buf,
size_t
n,
const
char
* format, ...)
{
va_list
arguments;
va_start
(arguments, format);
int
result =
PlatformSpecificVSNprintf
(buf, n, format, arguments);
va_end
(arguments);
return
result;
}
TEST
(SimpleString, PlatformSpecificSprintf_fits)
{
char
buf[
10
];
int
count =
WrappedUpVSNPrintf
(buf,
sizeof
(buf),
""
%s
""
,
""
12345
""
);
STRCMP_EQUAL
(
""
12345
""
, buf);
LONGS_EQUAL
(
5
, count);
}
TEST
(SimpleString, PlatformSpecificSprintf_doesNotFit)
{
char
buf[
10
];
int
count =
WrappedUpVSNPrintf
(buf,
sizeof
(buf),
""
%s
""
,
""
12345678901
""
);
STRCMP_EQUAL
(
""
123456789
""
, buf);
LONGS_EQUAL
(
11
, count);
}
TEST
(SimpleString, PadStringsToSameLengthString1Larger)
{
SimpleString
str1
(
""
1
""
);
SimpleString
str2
(
""
222
""
);
SimpleString::padStringsToSameLength
(str1, str2,
'
4
'
);
STRCMP_EQUAL
(
""
441
""
, str1.
asCharString
());
STRCMP_EQUAL
(
""
222
""
, str2.
asCharString
());
}
TEST
(SimpleString, PadStringsToSameLengthString2Larger)
{
SimpleString
str1
(
""
""
);
SimpleString
str2
(
""
""
);
SimpleString::padStringsToSameLength
(str1, str2,
'
'
);
STRCMP_EQUAL
(
""
""
, str1.
asCharString
());
STRCMP_EQUAL
(
""
""
, str2.
asCharString
());
}
TEST
(SimpleString, PadStringsToSameLengthWithSameLengthStrings)
{
SimpleString
str1
(
""
123
""
);
SimpleString
str2
(
""
123
""
);
SimpleString::padStringsToSameLength
(str1, str2,
'
'
);
STRCMP_EQUAL
(
""
123
""
, str1.
asCharString
());
STRCMP_EQUAL
(
""
123
""
, str2.
asCharString
());
}
TEST
(SimpleString, NullParameters2)
{
SimpleString* arr =
new
SimpleString[
100
];
delete[]
arr;
}
TEST
(SimpleString, CollectionMultipleAllocateNoLeaksMemory)
{
SimpleStringCollection col;
col.
allocate
(
5
);
col.
allocate
(
5
);
//
CHECK no memory leak
}
TEST
(SimpleString, CollectionReadOutOfBoundsReturnsEmptyString)
{
SimpleStringCollection col;
col.
allocate
(
3
);
STRCMP_EQUAL
(
""
""
, col[
3
].
asCharString
());
}
TEST
(SimpleString, CollectionWritingToEmptyString)
{
SimpleStringCollection col;
col.
allocate
(
3
);
col[
3
] =
SimpleString
(
""
HAH
""
);
STRCMP_EQUAL
(
""
""
, col[
3
].
asCharString
());
}
#
ifdef
CPPUTEST_64BIT
TEST
(SimpleString, 64BitAddressPrintsCorrectly)
{
char
* p = (
char
*)
0x0012345678901234
;
SimpleString
expected
(
""
0x12345678901234
""
);
SimpleString actual =
StringFrom
((
void
*)p);
STRCMP_EQUAL
(expected.
asCharString
(), actual.
asCharString
());
}
#
ifndef
CPPUTEST_64BIT_32BIT_LONGS
TEST
(SimpleString, BracketsFormattedHexStringFromForLongOnDifferentPlatform)
{
long
value = -
1
;
STRCMP_EQUAL
(
""
(0xffffffffffffffff)
""
,
BracketsFormattedHexStringFrom
(value).
asCharString
());
}
#
else
TEST
(SimpleString, BracketsFormattedHexStringFromForLongOnDifferentPlatform)
{
long
value = -
1
;
STRCMP_EQUAL
(
""
(0xffffffff)
""
,
BracketsFormattedHexStringFrom
(value).
asCharString
());
}
#
endif
#
else
/*
* This test case cannot pass on 32 bit systems.
*/
IGNORE_TEST
(SimpleString, 64BitAddressPrintsCorrectly)
{
}
TEST
(SimpleString, BracketsFormattedHexStringFromForLongOnDifferentPlatform)
{
long
value = -
1
;
STRCMP_EQUAL
(
""
(0xffffffff)
""
,
BracketsFormattedHexStringFrom
(value).
asCharString
());
}
#
endif
TEST
(SimpleString, BuildStringFromUnsignedLongInteger)
{
unsigned
long
int
i =
0xffffffff
;
SimpleString result =
StringFrom
(i);
const
char
* expected_string =
""
4294967295
""
;
CHECK_EQUAL
(expected_string, result);
}
TEST
(SimpleString, BuildStringFromUnsignedInteger)
{
unsigned
int
i =
0xff
;
SimpleString result =
StringFrom
(i);
const
char
* expected_string =
""
255
""
;
CHECK_EQUAL
(expected_string, result);
}
#
if
CPPUTEST_USE_STD_CPP_LIB
TEST
(SimpleString, fromStdString)
{
std::string
s
(
""
hello
""
);
SimpleString
s1
(
StringFrom
(s));
STRCMP_EQUAL
(
""
hello
""
, s1.
asCharString
());
}
TEST
(SimpleString, CHECK_EQUAL_unsigned_long)
{
unsigned
long
i =
0xffffffffUL
;
CHECK_EQUAL
(i, i);
}
TEST
(SimpleString, unsigned_long)
{
unsigned
long
i =
0xffffffffUL
;
SimpleString result =
StringFrom
(i);
const
char
* expected_string =
""
4294967295
""
;
CHECK_EQUAL
(expected_string, result);
}
#
endif
TEST
(SimpleString, StrCmp)
{
char
empty[] =
""
""
;
char
blabla[] =
""
blabla
""
;
char
bla[] =
""
bla
""
;
CHECK
(
SimpleString::StrCmp
(empty, empty) ==
0
);
CHECK
(
SimpleString::StrCmp
(bla, blabla) == -(
int
)
'
b
'
);
CHECK
(
SimpleString::StrCmp
(blabla, bla) ==
'
b
'
);
CHECK
(
SimpleString::StrCmp
(bla, empty) ==
'
b
'
);
CHECK
(
SimpleString::StrCmp
(empty, bla) == -(
int
)
'
b
'
);
CHECK
(
SimpleString::StrCmp
(bla, bla) ==
0
);
}
TEST
(SimpleString, StrNCpy_no_zero_termination)
{
char
str[] =
""
XXXXXXXXXX
""
;
STRCMP_EQUAL
(
""
womanXXXXX
""
,
SimpleString::StrNCpy
(str,
""
woman
""
,
5
));
}
TEST
(SimpleString, StrNCpy_zero_termination)
{
char
str[] =
""
XXXXXXXXXX
""
;
STRCMP_EQUAL
(
""
woman
""
,
SimpleString::StrNCpy
(str,
""
woman
""
,
6
));
}
TEST
(SimpleString, StrNCpy_null_proof)
{
POINTERS_EQUAL
(NULLPTR,
SimpleString::StrNCpy
(NULLPTR,
""
woman
""
,
6
));
}
TEST
(SimpleString, StrNCpy_stops_at_end_of_string)
{
char
str[] =
""
XXXXXXXXXX
""
;
STRCMP_EQUAL
(
""
woman
""
,
SimpleString::StrNCpy
(str,
""
woman
""
,
8
));
}
TEST
(SimpleString, StrNCpy_nothing_to_do)
{
char
str[] =
""
XXXXXXXXXX
""
;
STRCMP_EQUAL
(
""
XXXXXXXXXX
""
,
SimpleString::StrNCpy
(str,
""
woman
""
,
0
));
}
TEST
(SimpleString, StrNCpy_write_into_the_middle)
{
char
str[] =
""
womanXXXXX
""
;
SimpleString::StrNCpy
(str+
3
,
""
e
""
,
1
);
STRCMP_EQUAL
(
""
womenXXXXX
""
, str);
}
TEST
(SimpleString, StrNCmp_equal)
{
int
result =
SimpleString::StrNCmp
(
""
teststring
""
,
""
tests
""
,
5
);
LONGS_EQUAL
(
0
, result);
}
TEST
(SimpleString, StrNCmp_should_always_return_0_when_n_is_0)
{
int
result =
SimpleString::StrNCmp
(
""
a
""
,
""
b
""
,
0
);
LONGS_EQUAL
(
0
, result);
}
TEST
(SimpleString, StrNCmp_s1_smaller)
{
View remainder of file in raw view

Cpputest
CppUTest unit testing and mocking framework for C/C++
CppUTest
Core Manual
CppUMock Manual
Plugin Manual
Platforms stories
View on
GitHub
Download Release 3.8 as .zip
Download Release 3.8 as .tar.gz
Download Latest Passing Build .zip
Download Latest Passing Build .tar.gz
CppUTest is a C /C++ based unit xUnit test framework for unit testing and for test-driving your code. It is written in C++ but is used in C and C++ projects and frequently used in embedded systems.
CppUTest’s core design principles
Simple to use and small
Portable to old and new platforms
Build with Test-driven Development in mind"
Getting started,"Test Macros
Assertions
Setup and Teardown
Command Line Switches
Memory Leak Detection
Test Plugins
Scripts
Advanced Stuff
C Interface
Using Google Mock
Running Google Tests in CppUTest
Getting Started
Your first test
To write your first test, all you need is a new cpp file with a TEST_GROUP and a TEST, like:
#include ""CppUTest/TestHarness.h""
TEST_GROUP
(
FirstTestGroup
)
{
};
TEST
(
FirstTestGroup
,
FirstTest
)
{
FAIL
(
""Fail me!""
);
}
This test will fail. For adding new test_groups, this will be all you need to do (and make sure its compiled). If you want to add another test, all you need to do it:
TEST
(
FirstTestGroup
,
SecondTest
)
{
STRCMP_EQUAL
(
""hello""
,
""world""
);
}
One of the key design goals in CppUTest is to make it
very easy
to add and remove tests as this is something you’ll be doing a lot when test-driving your code.
Writing your main
Of course, in order to get it to run, you’ll need to create a main. Most of the mains in CppUTest are very similar. They typically are in an AllTests.cpp file and look like this:
#include ""CppUTest/CommandLineTestRunner.h""
int
main
(
int
ac
,
char
**
av
)
{
return
CommandLineTestRunner
::
RunAllTests
(
ac
,
av
);
}
CppUTest will automatically find your tests (as long as you don’t link them in a library).
Makefile changes
To get the above to work, you’ll need a Makefile or change your existing one. The needed changed are:
CppUTest path
If you have a system installed version (e.g. via apt-get) then you probably don’t need to change the path. Otherwise you’ll need to add CppUTest include directories to your Makefile. Usually this is done by definining a CppUTest path either as system variable or in the Makefile, such as:
CPPUTEST_HOME
=
/Users/vodde/workspace/cpputest
Compiler options
For the compiler you have to add the include path and optional (but recommended) the CppUTest pre-include header which enables debug information for the memory leak detector
and
offers memory leak detection in C. Lets start with the include path, you’ll need to add:
CPPFLAGS
+=
-I
$(CPPUTEST_HOME)
/include
(CPPFLAGS works for both .c and .cpp files!)
Then for the memory leak detection, you’ll need to add:
CXXFLAGS
+=
-include
$(CPPUTEST_HOME)
/include/CppUTest/MemoryLeakDetectorNewMacros.h
CFLAGS
+=
-include
$(CPPUTEST_HOME)
/include/CppUTest/MemoryLeakDetectorMallocMacros.h
These flags need to be added to
both
test code
and
production code. They will replace the malloc and new with a debug variant.
Linker options
You need to add CppUTest library to the linker flags, for example, like:
LD_LIBRARIES
=
-L
$(CPPUTEST_HOME)
/lib
-lCppUTest
-lCppUTestExt
(The last flag is only needed when you want to use extensions such as mocking)
Most commonly used Test Macros
TEST(group, name) - define a test
IGNORE_TEST(group, name) - turn off the execution of a test
TEST_GROUP(group) - Declare a test group to which certain tests belong.
This will also create the link needed from another library.
TEST_GROUP_BASE(group, base) - Same as TEST_GROUP, just use a different base class than Utest
IMPORT_TEST_GROUP(group) - Export the name of a test group so it can be linked in from a library (also see Advanced Stuff)
Set up and tear down support
Each TEST_GROUP may contain setup or teardown methods
Setup is called prior to each TEST body and Teardown is called after the test body
Assertions
The failure of one of these macros causes the current test to immediately exit:
CHECK(boolean condition) - checks any boolean result.
CHECK_TEXT(boolean condition, text) - checks any boolean result and prints text on failure.
CHECK_FALSE(condition) - checks any boolean result
CHECK_EQUAL(expected, actual) - checks for equality between entities using ==. So if you have a class that supports operator==() you can use this macro to compare two instances.  You will also need to add a StringFrom() function like those found in SimpleString. This is for printing the objects when the check failed.
CHECK_COMPARE(first, relop, second) - checks thats a relational operator holds between two entities. On failure, prints what both operands evaluate to.
CHECK_THROWS(expected_exception, expression) - checks if expression throws expected_exception (e.g. std::exception). CHECK_THROWS is only available if CppUTest is built with the Standard C++ Library (default).
STRCMP_EQUAL(expected, actual) - checks const char* strings for equality using strcmp().
STRNCMP_EQUAL(expected, actual, length) - checks const char* strings for equality using strncmp().
STRCMP_NOCASE_EQUAL(expected, actual) - checks const char* strings for equality, not considering case.
STRCMP_CONTAINS(expected, actual) - checks whether const char* actual contains const char* expected.
LONGS_EQUAL(expected, actual) - compares two numbers.
UNSIGNED_LONGS_EQUAL(expected, actual) - compares two positive numbers.
BYTES_EQUAL(expected, actual) - compares two numbers, eight bits wide.
POINTERS_EQUAL(expected, actual) - compares two pointers.
DOUBLES_EQUAL(expected, actual, tolerance) - compares two floating point numbers within some tolerance
FUNCTIONPOINTERS_EQUAL(expected, actual) - compares two void (*)() function pointers
MEMCMP_EQUAL(expected, actual, size) - compares two areas of memory
BITS_EQUAL(expected, actual, mask) - compares expected to actual bit by bit, applying mask
FAIL(text) - always fails
NOTE
Most macros have _TEXT() equivalents like CHECK_TEXT(), which are not explicitly listed here.
CHECK_EQUAL Warning:
CHECK_EQUAL(expected, actual) can produce misleading error reports as it will evaluate expected and actual more than once. This especially leads to confusions when used with mocks. This happens if the mock function expects to be called exactly once, since the macro needs to evaluate the actual expression more than once. The problem does not occur with type specific checks (e.g. LONGS_EQUAL()), so it is recommended to use them if possible. Instead of:
CHECK_EQUAL
(
10
,
mock_returning_11
())
which reports: Mock Failure: Unexpected additional call, rather use
LONGS_EQUAL
(
10
,
mock_returning_11
())
// reports actual different from expected
This issue could only be avoided with advanced language features like C++ templates, which would violate the CppUTest design goal portability to old environments.
Setup and Teardown
Every test group can have a setup and a teardown method. The setup method is called
before
each test and the teardown method is called
after
each test.
You can define setup and teardown like this:
TEST_GROUP
(
FooTestGroup
)
{
void
setup
()
{
// Init stuff
}
void
teardown
()
{
// Un-init stuff
}
};
TEST
(
FooTestGroup
,
Foo
)
{
// Test FOO
}
TEST
(
FooTestGroup
,
MoreFoo
)
{
// Test more FOO
}
TEST_GROUP
(
BarTestGroup
)
{
void
setup
()
{
// Init Bar
}
};
TEST
(
BarTestGroup
,
Bar
)
{
// Test Bar
}
The test execution of this will
likely
(no guarantee of order in CppUTest) be:
setup BarTestGroup
Bar
setup FooTestGroup
MoreFoo
teardown FooTestGroup
setup FooTestGroup
Foo
teardown FooTestGroup
Command line Switches
-c
colorize output, print green if OK, or red if failed
-g group
only run test whose group contains the substring
group
-k
package name, Add a package name in JUnit output (for classification in CI systems)
-lg
print a list of group names, separated by spaces
-ln
print a list of test names in the form of
group.name
, separated by spaces
-n name
only run test whose name contains the substring
name
-ojunit
output to JUnit ant plugin style xml files (for CI systems)
-oteamcity
output to xml files (as the name suggests, for TeamCity)
-p
run tests in a separate process.
-r#
repeat the tests some number (#) of times, or twice if # is not specified. This is handy if you are experiencing memory leaks. A second run that has no leaks indicates that someone is allocating statics and not releasing them.
-sg group
only run test whose group exactly matches the string
group
-sn name
only run test whose name exactly matches the string
name
-v
verbose, print each test name as it runs
-xg group
exclude tests whose group contains the substring
group
(v3.8)
-xn name
exclude tests whose name contains the substring
name
(v3.8)
“TEST(group, name)”
only run test whose group and name matches the strings group and name. This can be used to copy-paste output from the -v option on the command line.
You can specify multiple -s|sg, -s|sn and “TEST(group, name)” parameters:
Specifying only test groups with multiple -s|sg parameters will run all tests in those groups, since no test name matches all test names.
Specifying only test names with multiple -s|sn parameters will run all tests whose names match, since no test group matches all test groups.
Mixing multiple -s|sg and -s|sn parameters (or using “TEST(group, name)” will only run tests whose groups match as well as their names.
Combining one -xg parameter with one -xn parameter will run only those tests that satisfy both criteria.
Combining -s|sg with -xn, or -s|sn with -xg will run only those tests that satisfy both criteria.
Specifying several -xg or -xn with each other or in other combinations has no effect.
NOTE
Be careful with
-p
:
Some systems do not support this feature, in which case tests will fail
with a suitable message.
Using
-p
to run tests in a separate process can have unexpected side
effects.
While running tests in a separate process can help to get more information
about an unexpected crash, when an expected crash is part of the test scenario,
the
-p
command line option should not be used, but running in a separate
process should be enabled on a per-test basis like this:
TestRegistry
::
getCurrentRegistry
()
->
setRunTestsInSeperateProcess
();
Examples for this can be found in CppUTests’s own tests.
Memory Leak Detection
CppUTest has memory leak detection support on a per-test level. This means that it automatically checks whether the memory at the end of a test is the same as at the beginning of the test.
Explained another way:
Pre-setup -> Record the amount of memory used
Do setup
Run test
Do teardown
Post-teardown -> Check whether the amount of memory is the same
The memory leak detector consists of three parts:
Memory leak detector base (including linker symbols for operator new)
Macros overloading operator new for additional file and line info
Macros overloading malloc/free for memory leak detection in C
All of these are on by default. For the macro support, you’ll need to add to your Makefile:
CXXFLAGS
+=
-include
$(CPPUTEST_HOME)
/include/CppUTest/MemoryLeakDetectorNewMacros.h
CFLAGS
+=
-include
$(CPPUTEST_HOME)
/include/CppUTest/MemoryLeakDetectorMallocMacros.h
These are added by default when you use the CppUTest Makefile helpers.
Turning memory leak detection off and on
If you want to disable the memory leak detection (because you have too many memory leaks?) then you can do so in several ways. However, it is strongly recommended to keep the memory leak detector on and fix your memory leaks (and your static initialization issues) as this tends to lead to higher quality code.
You can turn the memory leak detection completely off by adding this to your main:
int
main
(
int
argc
,
char
**
argv
)
{
MemoryLeakWarningPlugin
::
turnOffNewDeleteOverloads
();
return
CommandLineTestRunner
::
RunAllTests
(
argc
,
argv
);
}
You can do the same by turning it off on a test by test basis, by adding this to the test group:
void
setup
()
{
MemoryLeakWarningPlugin
::
saveAndDisableNewDeleteOverloads
();
}
void
teardown
()
{
MemoryLeakWarningPlugin
::
restoreNewDeleteOverloads
();
}
(Do not forget to restore it in the teardown again!)
If you want to completely disable memory leak detection then you can do so by building CppUTest with
configure --disable-memory-leak-detection
or passing
-DCPPUTEST_MEM_LEAK_DETECTION_DISABLED
to the compiler when compiling CppUTest.
Conflicts with operator new macros (STL!)
It is common for the memory leak detection macros to conflict with an overloaded operator new or with STL. This is because the macro replaces the call to operator new to a call to operator new with
__FILE__
, and
__LINE__
. If you overload operator new, it will replace your overloaded definition resulting in a compiler error. This is common when using the Standard C++ library (STL).
Resolving conflicts with STL
The easiest way is to not pass the
--include MemoryLeakDetectionNewMacros.h
to the compiler, but this would lose all your file and line information. So this is not recommended. An alternative is to create your own NewMacros.h file which will include the STL file
before
the new macro is defined. For example, the following NewMacros file can be used for a program that uses std::list:
#include ""list""
#include ""CppUTest/MemoryLeakDetectorNewMacros.h""
Now the call to the compiler needs to be -include MyOwnNewMacros.h and this will ensure that the operator new overload is
before
the define and thus all compiler errors are resolved.
Conflicts with my own overload!
This one is harder (and luckily less common). You can solve this the same way as the conflict with the STL, but it’s probably better to use a finer grained control. So, instead you can temporary disable the new macros, overload operator new, enable the new macro again. This can be done with the following code:
class
NewDummyClass
{
public:
#if CPPUTEST_USE_NEW_MACROS
#undef new
#endif
void
*
operator
new
(
size_t
size
,
int
additional
)
#if CPPUTEST_USE_NEW_MACROS
#include ""CppUTest/MemoryLeakDetectorNewMacros.h""
#endif
{
// Do your thing!
}
};
Yes, its ugly. But usually people don’t overload operator new everywhere. If you do, consider turning off the new macro completely.
Other conflicts in the test file only
If your conflict is only in the test code files, put the CppUTest  includes after your includes.  Because of this potential conflict, its a good idea to put the CppUTest includes after your includes as a preemptive measure.
Conflicts with MFC
Tbd
Test Plugins
Test plugins let you add a pre-action and a post-action to each test case.  Plugin examples:
Memory leak detector (provided)
Pointer restore mechanism (provided) - helpful when tests overwrite a pointer that must be restored to its original value after the test.  This is especially helpful when a pointer to a function is modified for test purposes.
IEEE754 Floating point exceptions (provided; v3.8) - automatically checks whether any floating point exception flags are set at the end of every test and if so, fails the test.
All Mutex’s released - you could write a plugin that checks that any Mutexs or other shared resource is released before the test exits.
Complete Documentation for provided plugins can be found on the
Plugin Manual
page.
Scripts
There are some scripts that are helpful in creating your initial header, source, and
Test files.  These scripts save a lot of typing.  See scripts/README.TXT from the CppUTest distribution.
Advanced
Customize CHECK_EQUAL to work with your types that support operator==()
Create the function
SimpleString
StringFrom
(
const
yourType
&
)
The Extensions directory has a few of these.
Building default checks with TestPlugin
CppUTest can support extra checking functionality by inserting TestPlugins
TestPlugin is derived from the TestPlugin class and can be inserted in the TestRegistry via the installPlugin method.
All TestPlugins are called before and after running all tests and before and after running a single test (like Setup and Teardown). TestPlugins are typically inserted in the main.
TestPlugins can be used for, for example, system stability and resource handling like files, memory or network connection clean-up.
In CppUTest, the memory leak detection is done via a default enabled TestPlugin
How to run tests when they are linked in a library
In larger projects, it is often useful if you can link the tests in “libraries of tests” and then link them to the library of a component or link them all together to be able to run all the unit tests. Putting the tests in a library however causes an interesting problem because the lack of reference to the tests (due to the auto-registration of tests) causes the linker to discard the tests and it won’t run any of them. There are two different work-arounds for this:
You can use the IMPORT_TEST_GROUP macro to create a reference. This is typically done in the main.cpp or the main.h. You’ll need to do this for every single TEST_GROUP (and the tests groups shouldn’t be distributed over multiple files)
When you use gnu linker (on linux, but not MacOSX) then you can use an additional linker option that will make sure the whole library is linked. You do this by adding the library to be linked between the “-Wl,-whole-archive” and the -Wl,-no-whole-archive” options. For example:
gcc
-o
test_executable
production_library.a
-Wl,-whole-archive
test_library.a
-Wl,-no-whole-archive
$(OTHER_LIBRARIES)
C Interface
Sometimes, a C header will not compile under C++. For such cases, there are macros that allow you to specify test cases in a .c source, without involving C++ at all. There are also macro wrappers that pull these test cases into a .cpp source for CppUTest to work with. You will find all C macro definitions in TestHarness_c.h.
Here is a small example of how this is done.
First, the header of the function we want to test, PureCTests.h:
/** Legal C code that would not compile under C++ */
int
private
(
int
new
);
Next, the C file that defines our tests, PureCTests.c:
#include ""PureCTests_c.h""
/** the offending C header */
#include ""CppUTest/TestHarness_c.h""
#include ""CppUtestExt/MockSupport_c.h""
/** Mock for function internal() */
int
internal
(
int
new
)
{
mock_c
()
->
actualCall
(
""internal""
)
->
withIntParameters
(
""new""
,
new
);
return
mock_c
()
->
returnValue
().
value
.
intValue
;
}
/** Implementation of function to test */
int
private
(
int
new
)
{
return
internal
(
new
);
}
/** Setup and Teardown per test group (optional) */
TEST_GROUP_C_SETUP
(
mygroup
)
{
}
TEST_GROUP_C_TEARDOWN
(
mygroup
)
{
mock_c
()
->
checkExpectations
();
mock_c
()
->
clear
();
}
/** The actual tests for this test group */
TEST_C
(
mygroup
,
test_success
)
{
mock_c
()
->
expectOneCall
(
""internal""
)
->
withIntParameters
(
""new""
,
5
)
->
andReturnIntValue
(
5
);
int
actual
=
private
(
5
);
CHECK_EQUAL_C_INT
(
5
,
actual
);
}
TEST_C
(
mygroup
,
test_mockfailure
)
{
mock_c
()
->
expectOneCall
(
""internal""
)
->
withIntParameters
(
""new""
,
2
)
->
andReturnIntValue
(
5
);
int
actual
=
private
(
5
);
CHECK_EQUAL_C_INT
(
5
,
actual
);
}
TEST_C
(
mygroup
,
test_equalfailure
)
{
mock_c
()
->
expectOneCall
(
""internal""
)
->
withIntParameters
(
""new""
,
5
)
->
andReturnIntValue
(
2
);
int
actual
=
private
(
5
);
CHECK_EQUAL_C_INT
(
5
,
actual
);
}
Finally, the .cpp file that wraps it all up for CppUTest, PureCTests.cpp:
#include ""CppUTest/CommandLineTestRunner.h""
#include ""CppUTest/TestHarness_c.h""
/** For each C test group */
TEST_GROUP_C_WRAPPER
(
mygroup
)
{
TEST_GROUP_C_SETUP_WRAPPER
(
mygroup
);
/** optional */
TEST_GROUP_C_TEARDOWN_WRAPPER
(
mygroup
);
/** optional */
};
/** For each C test */
TEST_C_WRAPPER
(
mygroup
,
test_success
);
TEST_C_WRAPPER
(
mygroup
,
test_mockfailure
);
TEST_C_WRAPPER
(
mygroup
,
test_equalfailure
);
/** Test main as usual */
int
main
(
int
ac
,
char
**
av
)
{
return
RUN_ALL_TESTS
(
ac
,
av
);
}
You can leave out TEST_GROUP_C_SETUP() / TEST_GROUP_C_TEARDOWN() and TEST_GROUP_C_SETUP_WRAPPER() / TEST_GROUP_C_TEARDOWN_WRAPPER(), if you don’t need them.
The following assertion macros are supported in the pure C interface:
CHECK_EQUAL_C_BOOL
(
expected
,
actual
);
CHECK_EQUAL_C_INT
(
expected
,
actual
);
CHECK_EQUAL_C_UINT
(
expected
,
actual
);
CHECK_EQUAL_C_LONG
(
expected
,
actual
);
CHECK_EQUAL_C_ULONG
(
expected
,
actual
);
CHECK_EQUAL_C_LONGLONG
(
expected
,
actual
);
CHECK_EQUAL_C_ULONGLONG
(
expected
,
actual
);
CHECK_EQUAL_C_REAL
(
expected
,
actual
,
threshold
);
CHECK_EQUAL_C_CHAR
(
expected
,
actual
);
CHECK_EQUAL_C_UBYTE
(
expected
,
actual
);
CHECK_EQUAL_C_SBYTE
(
expected
,
actual
);
CHECK_EQUAL_C_STRING
(
expected
,
actual
);
CHECK_EQUAL_C_POINTER
(
expected
,
actual
);
/* v3.8 */
CHECK_EQUAL_C_BITS
(
expected
,
actual
,
mask
);
/* v3.8, pending */
FAIL_TEXT_C
(
text
);
FAIL_C
();
CHECK_C
(
condition
);
CHECK_C_TEXT
(
condition
,
text
);
NOTE
LONGLONG assertions are disabled by default.
NOTE2
All macros have _TEXT() equivalents like CHECK_C_TEXT(), which are not explicitly listed here.
These macros ensure tests get terminated in a way appropriate for pure C code.
Using Google Mock
You can use Google Mock directly in CppUTest. In order to do this, you’ll need to build with the real google mock. You do that like this:
$
GMOCK_HOME
=
/location/of/gmock
$
configure
--enable-gmock
$
make
$
make
install
Then in your tests, you can #include “CppUTestExt/GMock.h”. Do remember to set the CPPUTEST_USE_REAL_GMOCK define (pass -DCPPUTEST_USE_REAL_GMOCK to the compiler). Also, do not forget to link the CppUTestExt library.
This way you can use GMock directly in your code. For example:
class
MyMock
:
public
ProductionInterface
{
public:
MOCK_METHOD0
(
methodName
,
int
());
};
TEST
(
TestUsingGMock
,
UsingMyMock
)
{
NiceMock
<
MyMock
>
mock
;
EXPECT_CALL
(
mock
,
methodName
()).
Times
(
2
).
WillRepeatedly
(
Return
(
1
));
productionCodeUsing
(
mock
);
}
The above will probably leak to the memory leak detector complaining about memory leaks (in google mock). These aren’t really memory leaks, but they are static data that gtest (unfortunately) allocates on the first run. There are a couple of ways to get around that. First, you turn of the memory leak detector (see
Memory Leak Detection
). A better solutions is to use the GTestConvertor.
You can do that by adding the following code to your main:
#include ""CppUTestExt/GTestConvertor.h""
int
main
(
int
argc
,
char
**
argv
)
{
GTestConvertor
convertor
;
return
CommandLineTestRunner
::
RunAllTests
(
argc
,
argv
);
}
The most important line to add is the GTestConvertor. Make sure you define the CPPUTEST_USE_REAL_GTEST to signal the gtest dependency. (by adding -DCPPUTEST_USE_REAL_GTEST to the compiler)
Running Google Tests in CppUTest
People feel wonderfully religious about unit testing tools. Of course, we feel strongly that CppUTest beats other tools when you actually test-drive your software. But unfortunately, people still use tools like GoogleTest (which is actually not as bad as e.g. CppUnit). It is unlikely that we’re going to convince people to use CppUTest instead, so therefore we’ve written some integration code where you can actually link google test and CppUTest tests together in one binary (with the CppUTest test runner). This also gives you some additional benefits:
You get memory leak detection over your google tests…
You don’t get the verbose gtest output
You can use both CppUMock and GMock in one project
The way to do this is really quite simple. First, you’ll need to compile CppUtest with the GTest support enabled (by default this is off to prevent the dependency with GTest). You do that this way (assuming you want to use GMock too):
$
GMOCK_HOME
=
/location/of/gmock
$
configure
--enable-gmock
$
make
$
make
install
Or, if you don’t want to use GMock and only GTest then:
$
GMOCK_HOME
=
/location/of/gtest
$
configure
--enable-real-gtest
$
make
$
make
install
To let CppUTest know there are gtest being linked, you’ll need to add the following to the main:
#include ""./include/CppUTestExt/GTestConvertor.h""
int
main
(
int
argc
,
char
**
argv
)
{
GTestConvertor
convertor
;
convertor
.
addAllGTestToTestRegistry
();
return
CommandLineTestRunner
::
RunAllTests
(
argc
,
argv
);
}
(of course, you’ll need make sure you link also gtest and also add it to the include path.)

cpputest
/
CppUTestEclipsePlugin
Public
Notifications
You must be signed in to change notification settings
Fork
10
Star
18
Eclipse plugin for CppUTest unit test harness
18
stars
10
forks
Branches
Tags
Activity
Star
Notifications
You must be signed in to change notification settings
Code
Issues
10
Pull requests
0
Actions
Projects
0
Wiki
Security
Insights
Additional navigation options
Code
Issues
Pull requests
Actions
Projects
Wiki
Security
Insights
cpputest/CppUTestEclipsePlugin
master
Branches
Tags
Go to file
Code
Folders and files
Name
Name
Last commit message
Last commit date
Latest commit
History
46 Commits
org.cpputest.plugin.SWTBotTest
org.cpputest.plugin.SWTBotTest
org.cpputest.plugin.feature
org.cpputest.plugin.feature
org.cpputest.plugin.unittest
org.cpputest.plugin.unittest
org.cpputest.plugin
org.cpputest.plugin
update-site
update-site
README.txt
README.txt
pom.xml
pom.xml
View all files
Repository files navigation
README
CppUTest Eclipse Plugin
========================
CppUTest is a general purposed unit test framework for C/C++. This plugin is made to make unit testing esier to work with CppUTest & Eclipse.
The goal of this plugin is roughly:
1. Act like JUnit plugin (red/green bars!)
2. Support Test-Driven Developent
3. Make unit testing for legacy code easier
How To Build
------------------
mvn install
This will run the unit test & integration test and then generate the update package/site.
The update site is at update-site/target
How To Work On It
-------------------
1.clone the project
2.import projects from the folder
Each folder is a eclipse project, they are:
org.cpputest.plugin             The general plug-in implementation.
This part will do stub/mock code generation.
It does not depend on CDT
org.cpputest.runtools(planning) The cpputest run tools.
It will depend on CDT
org.cpputest.feature            Feature description of the plug-in
org.cpputest.plugin.unittest    Unit tests
SWTBotTest                      Integration test
In order to edit SWTBotTest project, you might need to install SWTBot eclipse plug-in.
About
Eclipse plugin for CppUTest unit test harness
Resources
Readme
Activity
Custom properties
Stars
18
stars
Watchers
6
watching
Forks
10
forks
Report repository
Releases
No releases published
Packages
0
No packages published
Contributors
3
Languages
Java
100.0%

Home
Features
Pricing
Docs
Announcements
Sign In
cpputest
/
cpputest
99%
Build:
DEFAULT BRANCH:
master
Repo Added
04 Mar 2016 07:20AM UTC
Files
48
Badge
Embed ▾
README BADGES
x
If you need to use a raster PNG badge, change the '.svg' to '.png' in the link
Markdown
[![Coverage Status](https://coveralls.io/repos/github/cpputest/cpputest/badge.svg?branch=master)](https://coveralls.io/github/cpputest/cpputest?branch=master)
Textile
https://coveralls.io/repos/github/cpputest/cpputest/badge.svg?branch=master(Coverage Status)!:https://coveralls.io/github/cpputest/cpputest?branch=master
RDoc
{<img src=""https://coveralls.io/repos/github/cpputest/cpputest/badge.svg?branch=master"" alt=""Coverage Status"" />}[https://coveralls.io/github/cpputest/cpputest?branch=master]
HTML
<a href='https://coveralls.io/github/cpputest/cpputest?branch=master'><img src='https://coveralls.io/repos/github/cpputest/cpputest/badge.svg?branch=master' alt='Coverage Status' /></a>
Rst
.. image:: https://coveralls.io/repos/github/cpputest/cpputest/badge.svg?branch=master
:target: https://coveralls.io/github/cpputest/cpputest?branch=master
LAST BUILD ON BRANCH
master
branch: master
CHANGE BRANCH
x
Reset
master
latest-passing-build
revert-1598-fix/junit_newline_encoding
v3.8
v4.0
Committed
23 Nov 2024 09:12AM UTC
coverage: 99.279%. Remained the same
Build #
11985935461
Build Type
push
github
Committed by
web-flow
Commit Message
Merge pull request #1830 from thetic/CMP0175
Resolve new CMake warning
Run Details
6749
of
6798
relevant lines covered
(99.28%)
18722.56
hits per line
Relevant lines Covered
Build:
Build:
6798
RELEVANT LINES
6749
COVERED LINES
18722.56
HITS PER LINE
Source Files on
master
Tree
List
48
Changed
2
Source Changed
0
Coverage Changed
0
Coverage
∆
File
Lines
Relevant
Covered
Missed
Hits/Line
Recent builds
Builds
Branch
Commit
Type
Ran
Committer
Via
Coverage
11985935461
master
Merge pull request #1830 from thetic/CMP0175
Resolve new CMake warning
push
23 Nov 2024 09:13AM UTC
web-flow
github
99.28
10897585667
master
Merge pull request #1808 from thetic/iar
Improve CMake/IAR support
push
17 Sep 2024 06:19AM UTC
web-flow
github
99.28
10791701767
master
Merge pull request #1815 from thetic/bad-warning
Suppress warning from generated autotools header
push
10 Sep 2024 11:43AM UTC
web-flow
github
99.28
10779030402
master
Merge pull request #1814 from basvodde/master
Added missing test for \r in JUnitTestOutputTest
push
09 Sep 2024 06:27PM UTC
web-flow
github
99.28
10778947823
master
Merge
b76fc5707
into
4b317d463
Pull #1814
09 Sep 2024 06:20PM UTC
web-flow
github
99.28
10778529187
master
Merge pull request #1812 from basvodde/master
Removed #include too much
push
09 Sep 2024 05:53PM UTC
web-flow
github
99.28
10778443620
master
Merge
63d9aafe6
into
5e5562a86
Pull #1812
09 Sep 2024 05:48PM UTC
web-flow
github
99.28
10778420353
master
Merge pull request #1811 from basvodde/master
Fixing PlatformSpecificFPuts conflict between JUnitOutputTest and TestOutput
push
09 Sep 2024 05:45PM UTC
web-flow
github
99.28
10778290800
master
Merge
5cb47b469
into
a1d7bf2ee
Pull #1811
09 Sep 2024 05:35PM UTC
web-flow
github
99.28
10774291170
master
Merge pull request #1806 from thetic/unreserved
Remove excessive warning suppressions
push
09 Sep 2024 01:32PM UTC
web-flow
github
99.28
See All Builds (1489)
Repo on GitHub
STATUS
·
Troubleshooting
·
Open an Issue
·
Sales
·
Support
·
CAREERS
·
ENTERPRISE
·
START FREE
·
SCHEDULE DEMO
ANNOUNCEMENTS
·
TWITTER
·
TOS & SLA
·
Supported CI Services
·
What's a CI service?
·
Automated Testing
© 2024 Coveralls, Inc

jwgrenning
/
cpputest-starter-project-vs
Public
Notifications
You must be signed in to change notification settings
Fork
12
Star
20
A cpputest starter project with instructions for visual studio
20
stars
12
forks
Branches
Tags
Activity
Star
Notifications
You must be signed in to change notification settings
Code
Issues
2
Pull requests
1
Actions
Projects
0
Wiki
Security
Insights
Additional navigation options
Code
Issues
Pull requests
Actions
Projects
Wiki
Security
Insights
jwgrenning/cpputest-starter-project-vs
master
Branches
Tags
Go to file
Code
Folders and files
Name
Name
Last commit message
Last commit date
Latest commit
History
17 Commits
example-include
example-include
example-platform
example-platform
example-src
example-src
readme
readme
tests
tests
vs-test-build
vs-test-build
.gitignore
.gitignore
Copyright.txt
Copyright.txt
README.md
README.md
View all files
Repository files navigation
README
License
cpputest-starter-project-vs
A cpputest starter project with instructions for Visual Studio
Create Your First Legacy C/C++ Test Project - Visual Studio
This describes how to integrate CppUTest based testing into your production code base using the Visual Studio environment.  I'll assume you are using Visual Studio 2010 in the instructions, but there are other project files. As a reference, here are the other Visual Studio file extensions:
• VC6 file extensions (dsw, dsp)
• VS2008 file extensions (sln, vcproj)
• VS2010 file extensions (sln, vcxproj)
• VS2012 file extensions (sln, vcxproj)
• VS2019 file extensions (sln, vcxproj)
Install and build CppUTest
Go to cpputest.org, and download the latest cpputest.
Follow the instructions for building it.
Add an environment variable called CPPUTEST_HOME to your environment variables that points the home directory of CppUTest.
Open the CppUTest visual studio solution. (e.g., cpputest-3.8\CppUTest_VS201x.sln)
Make sure to upgrade the current Visual Studio tools. (e.g., for Visual Studio 2019: right-click the solution, and then select ""Retarget solution"")
Build: ""Menu Debug, Start Without Debugging"" (assuming VS 2019)
You should see these test results in the console window:
...................................
OK (1085 tests, 1037 ran, 2505 checks, 48 ignored, 0 filtered out, 331 ms)
Unzip and build the starter project
Clone the starter-kit like this:
git clone https://github.com/jwgrenning/cpputest-starter-project-vs.git
open the solution cpputest-starter-project-vs/vs-test-build/TddC-StarterProject_VS2010.sln (or the solution best suited to your VS version)
Make sure to upgrade the current Visual Studio tools. (e.g., for Visual Studio 2019: right-click the solution, and then select ""Retarget solution"")
Build: ""Menu Debug, Start Without Debugging"" (assuming VS 2019)
You should see these test results in the console window:
..
OK (2 tests, 2 ran, 1 checks, 0 ignored, 0 filtered out, 0 ms)
How to integrate testing into your source repository.
Move starter test files to your production code repository
Test files and production code files should all be kept in version control.
Assuming your code is already in version control (if not, why not?!), this section describes how to integrate testing into your source repository.
Let's presume a directory structure like this:
ProductRepository
|-- include
|-- source
Add a directory called 'tests' to ProductSourceRepository
Add a directory called 'example-src' to ProductSourceRepository
Add a directory called 'vs-test-build' to ProductSourceRepository
Copy the following files to your ProductRepository
• example-include/example.h
• example-include/io.h
• example-platform/io.c
• example-src/example.c
• tests/*.cpp
• vs-test-build/AllTests.vcxproj (VS2010)
• vs-test-build/ProductionCodeLib.vcxproj (VS2010)
• vs-test-build/TddC-StarterProject.dsw
• vs-test-build/TddC-StarterProject_VS2010.sln (VS2010)
You should now have this directory structure (assuming VS2010)
ProductSourceRepository
|-- example-include
|-- example.h
|-- io.h
|-- example-platform
|-- io.c
|-- example-src
|-- example.c
|-- include
|-- source
|-- tests
|-- AllTests.cpp
|-- ExampleTest.cpp
|-- MyFirstTest.cpp
|-- vs-test-build
|-- AllTests.vcxproj
|-- ProductionCodeLib.vcxproj
|-- TddC-StarterProject.dsw
|-- TddC-StarterProject_VS2010.sln
Open the TddC-StarterProject_VS2010.sln
Right-click on the solution and select ""Clean all""
Build the solution: ""Menu Debug, Start Without Debugging""
You should see these test results in the console window:
..
OK (2 tests, 2 ran, 1 checks, 0 ignored, 0 filtered out, 2 ms)
Cause the test to fail.  Open example.c, change the return result to 0.  You should see:
.
tests\ExampleTest.cpp(21): error: Failure in TEST(Example, test1)
expected <1 0x1>
but was  <0 0x0>
.
Errors (1 failures, 2 tests, 2 ran, 1 checks, 0 ignored, 0 filtered out, 14 ms)
Restore the example()'s return result to 1 and see tests pass again.
Things that can go wrong:
You build fails because it cannot find CppUTest includes
Define the environment variable CPPUTEST_HOME to be equal to the location of CppUTest
Visual Studio Intellisense won't work properly / Code Navigation does not work
The the .vs folder or the .suo file contains cached IntelliSense data
Shut down the Visual Studio
Delete the .vs folder or the .suo file
Restart the Visual Studio
About
A cpputest starter project with instructions for visual studio
Resources
Readme
Activity
Stars
20
stars
Watchers
4
watching
Forks
12
forks
Report repository
Releases
No releases published
Packages
0
No packages published
Contributors
2
Languages
C
88.0%
C++
12.0%

cpputest
/
cpputest
Public
Notifications
You must be signed in to change notification settings
Fork
516
Star
1.4k
Code
Issues
168
Pull requests
19
Discussions
Actions
Projects
0
Security
Insights
Additional navigation options
Code
Issues
Pull requests
Discussions
Actions
Projects
Security
Insights
Files
master
Breadcrumbs
cpputest
/
tests
/
CppUTestExt
/
MockSupportTest.cpp
Blame
Blame
Latest commit
History
History
286 lines (241 loc) · 9.01 KB
master
Breadcrumbs
cpputest
/
tests
/
CppUTestExt
/
MockSupportTest.cpp
Top
File metadata and controls
Code
Blame
286 lines (241 loc) · 9.01 KB
Raw
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
/*
* Copyright (c) 2007, Michael Feathers, James Grenning and Bas Vodde
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the <organization> nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE EARLIER MENTIONED AUTHORS ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL <copyright holder> BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#
include
""
CppUTest/TestHarness.h
""
#
include
""
CppUTest/TestTestingFixture.h
""
#
include
""
CppUTestExt/MockSupport.h
""
#
include
""
CppUTestExt/MockExpectedCall.h
""
#
include
""
CppUTestExt/MockFailure.h
""
#
include
""
MockFailureReporterForTest.h
""
TEST_GROUP
(MockSupportTest)
{
MockExpectedCallsListForTest expectations;
MockFailureReporterInstaller failureReporterInstaller;
void
teardown
() CPPUTEST_OVERRIDE
{
mock
().
checkExpectations
();
CHECK_NO_MOCK_FAILURE
();
MockFailureReporterForTest::clearReporter
();
mock
().
clear
();
}
};
TEST
(MockSupportTest, setDataForUnsignedIntegerValues)
{
unsigned
int
expected_data =
7
;
mock
().
setData
(
""
data
""
, expected_data);
LONGS_EQUAL
(expected_data,
mock
().
getData
(
""
data
""
).
getUnsignedIntValue
());
}
TEST
(MockSupportTest, setDataForIntegerValues)
{
int
expected_data =
10
;
mock
().
setData
(
""
data
""
, expected_data);
LONGS_EQUAL
(expected_data,
mock
().
getData
(
""
data
""
).
getIntValue
());
}
TEST
(MockSupportTest, setDataForBooleanValues)
{
bool
expected_data =
true
;
mock
().
setData
(
""
data
""
, expected_data);
CHECK_EQUAL
(expected_data,
mock
().
getData
(
""
data
""
).
getBoolValue
());
}
TEST
(MockSupportTest, hasDataBeenSet)
{
CHECK
(!
mock
().
hasData
(
""
data
""
));
mock
().
setData
(
""
data
""
,
10
);
CHECK
(
mock
().
hasData
(
""
data
""
));
}
TEST
(MockSupportTest, dataCanBeChanged)
{
mock
().
setData
(
""
data
""
,
10
);
mock
().
setData
(
""
data
""
,
15
);
LONGS_EQUAL
(
15
,
mock
().
getData
(
""
data
""
).
getIntValue
());
}
TEST
(MockSupportTest, uninitializedData)
{
LONGS_EQUAL
(
0
,
mock
().
getData
(
""
nonexisting
""
).
getIntValue
());
STRCMP_EQUAL
(
""
int
""
,
mock
().
getData
(
""
nonexisting
""
).
getType
().
asCharString
());
}
TEST
(MockSupportTest, setMultipleData)
{
mock
().
setData
(
""
data
""
,
1
);
mock
().
setData
(
""
data2
""
,
10
);
LONGS_EQUAL
(
1
,
mock
().
getData
(
""
data
""
).
getIntValue
());
LONGS_EQUAL
(
10
,
mock
().
getData
(
""
data2
""
).
getIntValue
());
}
TEST
(MockSupportTest, setDataString)
{
mock
().
setData
(
""
data
""
,
""
string
""
);
STRCMP_EQUAL
(
""
string
""
,
mock
().
getData
(
""
data
""
).
getStringValue
());
}
TEST
(MockSupportTest, setDataDouble)
{
mock
().
setData
(
""
data
""
,
1.0
);
DOUBLES_EQUAL
(
1.0
,
mock
().
getData
(
""
data
""
).
getDoubleValue
(),
0.05
);
}
TEST
(MockSupportTest, setDataPointer)
{
void
* ptr = (
void
*)
0x001
;
mock
().
setData
(
""
data
""
, ptr);
POINTERS_EQUAL
(ptr,
mock
().
getData
(
""
data
""
).
getPointerValue
());
}
TEST
(MockSupportTest, setConstDataPointer)
{
const
void
* ptr = (
const
void
*)
0x001
;
mock
().
setData
(
""
data
""
, ptr);
POINTERS_EQUAL
(ptr,
mock
().
getData
(
""
data
""
).
getConstPointerValue
());
}
TEST
(MockSupportTest, setDataFunctionPointer)
{
void
(*ptr)() = (
void
(*)())
0x001
;
mock
().
setData
(
""
data
""
, ptr);
FUNCTIONPOINTERS_EQUAL
(ptr,
mock
().
getData
(
""
data
""
).
getFunctionPointerValue
());
}
TEST
(MockSupportTest, setDataObject)
{
void
* ptr = (
void
*)
0x001
;
mock
().
setDataObject
(
""
data
""
,
""
type
""
, ptr);
POINTERS_EQUAL
(ptr,
mock
().
getData
(
""
data
""
).
getObjectPointer
());
STRCMP_EQUAL
(
""
type
""
,
mock
().
getData
(
""
data
""
).
getType
().
asCharString
());
}
TEST
(MockSupportTest, setDataConstObject)
{
void
* ptr = (
void
*)
0x011
;
mock
().
setDataConstObject
(
""
data
""
,
""
type
""
, ptr);
POINTERS_EQUAL
(ptr,
mock
().
getData
(
""
data
""
).
getConstObjectPointer
());
STRCMP_EQUAL
(
""
type
""
,
mock
().
getData
(
""
data
""
).
getType
().
asCharString
());
}
TEST
(MockSupportTest, tracing)
{
mock
().
tracing
(
true
);
mock
().
actualCall
(
""
boo
""
).
withParameter
(
""
double
""
,
1.0
).
withParameter
(
""
int
""
,
1
).
withParameter
(
""
string
""
,
""
string
""
);
mock
(
""
scope
""
).
actualCall
(
""
foo
""
).
withParameter
(
""
double
""
,
1.0
).
withParameter
(
""
int
""
,
1
).
withParameter
(
""
string
""
,
""
string
""
);
mock
().
checkExpectations
();
STRCMP_CONTAINS
(
""
boo
""
,
mock
().
getTraceOutput
());
STRCMP_CONTAINS
(
""
foo
""
,
mock
().
getTraceOutput
());
}
TEST
(MockSupportTest, tracingWorksHierarchically)
{
mock
(
""
scope
""
).
tracing
(
true
);
mock
().
tracing
(
true
);
mock
().
actualCall
(
""
boo
""
);
mock
(
""
scope
""
).
actualCall
(
""
foo
""
);
mock
().
checkExpectations
();
STRCMP_CONTAINS
(
""
boo
""
,
mock
().
getTraceOutput
());
STRCMP_CONTAINS
(
""
foo
""
,
mock
().
getTraceOutput
());
}
TEST_GROUP
(MockSupportTestWithFixture)
{
TestTestingFixture fixture;
void
teardown
() CPPUTEST_OVERRIDE
{
mock
().
clear
();
MockFailureReporterForTest::clearReporter
();
}
};
static
void
CHECK_EXPECTED_MOCK_FAILURE_LOCATION_failedTestMethod_
()
{
MockExpectedCallsList list;
MockUnexpectedCallHappenedFailure
expectedFailure
(
UtestShell::getCurrent
(),
""
unexpected
""
, list);
mock
().
actualCall
(
""
boo
""
);
CHECK_EXPECTED_MOCK_FAILURE_LOCATION
(expectedFailure,
""
file
""
,
1
);
}
TEST
(MockSupportTestWithFixture, CHECK_EXPECTED_MOCK_FAILURE_LOCATION_failed)
{
mock
().
setMockFailureStandardReporter
(
MockFailureReporterForTest::getReporter
());
fixture.
setTestFunction
(CHECK_EXPECTED_MOCK_FAILURE_LOCATION_failedTestMethod_);
fixture.
runAllTests
();
fixture.
assertPrintContains
(
""
MockFailures are different.
""
);
fixture.
assertPrintContains
(
""
Expected MockFailure:
""
);
fixture.
assertPrintContains
(
""
Mock Failure: Unexpected call to function: unexpected
""
);
fixture.
assertPrintContains
(
""
Actual MockFailure:
""
);
fixture.
assertPrintContains
(
""
Mock Failure: Unexpected call to function: boo
""
);
}
static
void
CHECK_NO_MOCK_FAILURE_LOCATION_failedTestMethod_
()
{
mock
().
actualCall
(
""
boo
""
);
CHECK_NO_MOCK_FAILURE_LOCATION
(
""
file
""
,
1
);
}
TEST
(MockSupportTestWithFixture, CHECK_NO_MOCK_FAILURE_LOCATION_failed)
{
mock
().
setMockFailureStandardReporter
(
MockFailureReporterForTest::getReporter
());
fixture.
setTestFunction
(CHECK_NO_MOCK_FAILURE_LOCATION_failedTestMethod_);
fixture.
runAllTests
();
fixture.
assertPrintContains
(
""
Unexpected mock failure:
""
);
fixture.
assertPrintContains
(
""
Mock Failure: Unexpected call to function: boo
""
);
}
static
bool
cpputestHasCrashed;
static
void
crashMethod
()
{
cpputestHasCrashed =
true
;
}
static
void
unexpectedCallTestFunction_
(
void
)
{
mock
().
actualCall
(
""
unexpected
""
);
}
//
LCOV_EXCL_LINE
#
include
""
CppUTestExt/OrderedTest.h
""
TEST
(MockSupportTestWithFixture, shouldCrashOnFailure)
{
cpputestHasCrashed =
false
;
mock
().
crashOnFailure
(
true
);
UtestShell::setCrashMethod
(crashMethod);
fixture.
setTestFunction
(unexpectedCallTestFunction_);
fixture.
runAllTests
();
CHECK
(cpputestHasCrashed);
mock
().
crashOnFailure
(
false
);
UtestShell::resetCrashMethod
();
}
TEST
(MockSupportTestWithFixture, ShouldNotCrashOnFailureAfterCrashMethodWasReset)
{
cpputestHasCrashed =
false
;
UtestShell::setCrashMethod
(crashMethod);
fixture.
setTestFunction
(unexpectedCallTestFunction_);
UtestShell::resetCrashMethod
();
fixture.
runAllTests
();
fixture.
assertPrintContains
(
""
Unexpected call to function: unexpected
""
);
CHECK_FALSE
(cpputestHasCrashed);
}
TEST
(MockSupportTestWithFixture, shouldCrashOnFailureWithCppUTestSetting)
{
cpputestHasCrashed =
false
;
UtestShell::setCrashOnFail
();
UtestShell::setCrashMethod
(crashMethod);
fixture.
setTestFunction
(unexpectedCallTestFunction_);
fixture.
runAllTests
();
CHECK
(cpputestHasCrashed);
UtestShell::restoreDefaultTestTerminator
();
UtestShell::resetCrashMethod
();
}
TEST
(MockSupportTestWithFixture, failedMockShouldFailAgainWhenRepeated)
{
fixture.
setTestFunction
(unexpectedCallTestFunction_);
int
repeatCount =
2
;
while
(repeatCount--)
{
fixture.
runAllTests
();
fixture.
assertPrintContains
(
""
Unexpected call to function: unexpected
""
);
fixture.
assertPrintContains
(
""
Errors (1 failures, 1 tests, 1 ran, 0 checks, 0 ignored, 0 filtered out
""
);
fixture.
flushOutputAndResetResult
();
}
}

Services ▼
Training
Coaching and Consulting
Workshops
Contact ▼
Contact
Join our mailing list
About
Resources ▼
Blog
Papers and Presentation
-- Titles
-- Titles & Synopsis
Stories From the Field
What Developers Like about TDD
Join our mailing list
CppUTest
Testimonials
Attendee Feedback - Training
Attendee Feedback - Workshop
Attendee Preparation Replies
Attendee 1st impressions of TDD
Sign in
Test-Driven Development for Embedded C
James Grenning
, founder of Wingman Software, is the author of Test-Driven Developement for Embedded C.
Why Test-Driven Development for Embedded C?
Read
Jack Ganssle's Foreword
Read
Robert Martin's Foreword
Download
the first 16 pages
with table of contents, quotes and forewords.
Download
an exerpt from TDD for Embedded C
explaining the problem solved by TDD, what it is, and benefits to expect.
Read reviews at
Amazon
or
Good Reads
Buy the paper or ebook
here
.
Please respct my work and our no DRM policy.  Don't use pirated copies.
Have you read Test-Driven Development for Embedded C?
Please write a review for Test-Driven Development for Embedded C at
Amazon
or
Good Reads
.
Do you like TDD for Embedded C? Tweet it!
Tweet
Latest News
Self-Paced TDD for Embedded C Training Beta!
We have our self-paced TDD Training in beta.
more...
Conference Video - Deep Stack – Tracer Bullets from ADC to Browser
A blank page can be very intimidating, even for a Test-driven developer. Where do we start? Write a test, right? Not always.
more...
Podcast on Agile Amped
Here is a short interview with James about TDD and embedded software from the deliver:Agile conference last spring.
more...
Twitter, Facebook, Linked-in and Quora
James participated on these social media platforms.
more...
Programming Research -- Please Participate
Do you have some time to do a simple programming problem in C or C++ for my research?
more...
Clean Coders IoT Case Study
My long-time good friend (Uncle) Bob Martin and I have fun programming together firing tracer bullets for distributed water pressure measurement system.
more...
Reviews of our training
Here are a couple reviews of our TDD for Embedded C training.
more...
Loading news...
Books
James is the author of Test-Driven Development for Embedded C.
Have you read Test-Driven Development for Embedded C? Please write a review at
Amazon
or
Good Reads
.
Find out more
Resources
Papers and Presentations
CppUTest
Testimonials
Customer Feedback
Services
Coaching
Training
Workshops
You've read Test-Driven Development for Embedded C? Please write a review at
Amazon
or
Good Reads
.
Wingman Software
Our mission is to bring state of the art Agile Development and Design Techniques
to the embedded software community.  We also support non-embedded companies adopting
Agile methods to advance their technical practices in design, Test Driven Development,
Refactoring and acceptance testing.
Get in touch
Contact
form
Twitter
@jwgrenning
Email
info -at- wingman-sw.com
Address
Bonita Springs
FL 34135
USA
Phone
+1 847-630-0998
© Wingman Software 2014-2018. All rights reserved | Design:
Dave Rooney
using
ZeroFour, a template by
ajlkn
for
HTML5 UP

cpputest
/
cpputest
Public
Notifications
You must be signed in to change notification settings
Fork
516
Star
1.4k
Code
Issues
168
Pull requests
19
Discussions
Actions
Projects
0
Security
Insights
Additional navigation options
Code
Issues
Pull requests
Discussions
Actions
Projects
Security
Insights
Issues: cpputest/cpputest
Labels
6
Milestones
0
Labels
6
Milestones
0
New issue
Have a question about this project?
Sign up for a free GitHub account to open an issue and contact its maintainers and the community.
Sign up for GitHub
By clicking “Sign up for GitHub”, you agree to our
terms of service
and
privacy statement
. We’ll occasionally send you account related emails.
Already on GitHub?
Sign in
to your account
168 Open
462 Closed
168 Open
462 Closed
Author
Filter by author
Loading
author:
Filter by this user
Label
Filter by label
Loading
Use
alt
+
click/return
to exclude labels
or
⇧
+
click/return
for logical OR
Projects
Filter by project
Loading
Milestones
Filter by milestone
Loading
Assignee
Filter by who’s assigned
Assigned to nobody
Loading
assignee:
Filter by this user
Sort
Sort by
Newest
Oldest
Most commented
Least commented
Recently updated
Least recently updated
Best match
Most reactions
👍
👎
😄
🎉
😕
❤️
🚀
👀
Issues list
Can we rename HAVE_CONFIG_H?
#1829
opened
Nov 20, 2024
by
mtfurlan
5
TestHarness.h - Compile errors in C++ headers unless #include <memory> is added
#1827
opened
Nov 8, 2024
by
sktpin
1
PROJECT_IS_TOP_LEVEL while using externalproject_add
#1825
opened
Sep 30, 2024
by
KammutierSpule
10
long long again
#1824
opened
Sep 28, 2024
by
KammutierSpule
4
Help detecting tests on ESP32 IDF
#1823
opened
Sep 28, 2024
by
KammutierSpule
9
old Visual C++ builds are broken.
#1822
opened
Sep 27, 2024
by
thetic
Can not link a library built with boost.json with a unit test executable built with cpputest
#1818
opened
Sep 18, 2024
by
DBizz22
GetPlatformSpecificTimeInMillis will run out of range on 32bit platforms in 2038
#1798
opened
May 31, 2024
by
maciejmatuszak
1
Stupid beginners problem
#1794
opened
May 12, 2024
by
FreekyFrank
4
Change or remove
include/Platforms/c2000/stdint.h
#1792
opened
May 10, 2024
by
fgrie
4
Small Issue in FakeTimeService.c
#1791
opened
May 8, 2024
by
FreekyFrank
Counter-intuitive (erroneous?) behavior with test groups
#1790
opened
May 6, 2024
by
fgrie
Wrong error message if mock is used
#1775
opened
Mar 27, 2024
by
f-zl
1
MockCheckedExpectedCall::callToString(): Why are output parameters handled differently than input parameters?
#1770
opened
Jan 31, 2024
by
swilli
Hello my friends, I wonder how to mock a c library function by using cpputest. Thanks very much.
#1769
opened
Dec 19, 2023
by
FrankLiang826
Using a named scope mock results in memory leak unless global scope is used for clear()
#1764
opened
Nov 9, 2023
by
icvidal
Question/Bug: runing state and order dependent tests with ctest
#1758
opened
Aug 11, 2023
by
stefaneicher
1
Coverage report for CMake
#1754
opened
May 22, 2023
by
david-drinn
1
How to use withFunctionPointerParameter
#1753
opened
May 22, 2023
by
mundodisco8
cout only if -v option is given?
#1752
opened
Apr 13, 2023
by
CodeFatherG
2
Memory leak(s) found for the QDate object created with the fromString(const QString &string, const QString &format, QCalendar cal = QCalendar()) static method.
#1749
opened
Mar 9, 2023
by
Vilcrow
cpputest on target: make -C ../../../platforms_startup is missing
#1747
opened
Feb 15, 2023
by
nandlol
find_package fails in version 4.0.2 with
#1743
opened
Jan 18, 2023
by
HinrichAue
2
Intermingled test from different test groups will result in missing test cases in junit.xml
#1741
opened
Jan 9, 2023
by
AlanRosenthal
1
Actions use deprecated
set-output
and Node v12
#1734
opened
Dec 29, 2022
by
thetic
Previous
1
2
3
4
5
6
7
Next
Previous
Next
ProTip!
Mix and match filters to narrow down what you’re looking for.

cpputest
/
cpputest
Public
Notifications
You must be signed in to change notification settings
Fork
516
Star
1.4k
CppUTest unit testing and mocking framework for C/C++
cpputest.github.io
License
BSD-3-Clause license
1.4k
stars
516
forks
Branches
Tags
Activity
Star
Notifications
You must be signed in to change notification settings
Code
Issues
168
Pull requests
19
Discussions
Actions
Projects
0
Security
Insights
Additional navigation options
Code
Issues
Pull requests
Discussions
Actions
Projects
Security
Insights
cpputest/cpputest
master
Branches
Tags
Go to file
Code
Folders and files
Name
Name
Last commit message
Last commit date
Latest commit
History
4,605 Commits
.circleci
.circleci
.github/
workflows
.github/
workflows
build
build
builds
builds
cmake
cmake
docker
docker
examples
examples
include
include
m4
m4
platforms
platforms
platforms_examples
platforms_examples
scripts
scripts
src
src
tests
tests
.clang-format
.clang-format
.clang-tidy
.clang-tidy
.git-blame-ignore-revs
.git-blame-ignore-revs
.gitattributes
.gitattributes
.gitignore
.gitignore
.travis.yml
.travis.yml
AUTHORS
AUTHORS
CMakeLists.txt
CMakeLists.txt
CMakePresets.json
CMakePresets.json
COPYING
COPYING
ChangeLog
ChangeLog
CppUTest.sln
CppUTest.sln
CppUTest.vcproj
CppUTest.vcproj
CppUTest.vcxproj
CppUTest.vcxproj
CppUTestConfig.cmake.build.in
CppUTestConfig.cmake.build.in
CppUTestConfig.cmake.install.in
CppUTestConfig.cmake.install.in
CppUTest_VS201x.sln
CppUTest_VS201x.sln
Doxyfile
Doxyfile
Makefile.am
Makefile.am
Makefile_CppUTestExt
Makefile_CppUTestExt
Makefile_using_MakefileWorker
Makefile_using_MakefileWorker
NEWS
NEWS
README
README
README.md
README.md
README_CppUTest_for_C.txt
README_CppUTest_for_C.txt
README_InstallCppUTest.txt
README_InstallCppUTest.txt
appveyor.yml
appveyor.yml
autogen.sh
autogen.sh
config.h.cmake
config.h.cmake
configure.ac
configure.ac
cpputest.pc.in
cpputest.pc.in
cpputest_doxy_gen.conf
cpputest_doxy_gen.conf
gcovr.cfg
gcovr.cfg
makeVS2008.bat
makeVS2008.bat
makeVS201x.bat
makeVS201x.bat
valgrind.suppressions
valgrind.suppressions
View all files
Repository files navigation
README
BSD-3-Clause license
CppUTest
CppUTest unit testing and mocking framework for C/C++
More information on the project page
Slack channel:
Join if link not expired
Getting Started
You'll need to do the following to get started:
Building from source (Unix-based, Cygwin, MacOS):
git clone https://github.com/cpputest/cpputest.git
cd
cpputest
mkdir cpputest_build
cd
cpputest_build
autoreconf .. -i
../configure
make
You can use
make install
if you want to install CppUTest system-wide.
You can also use CMake, which also works for Windows Visual Studio.
git clone https://github.com/cpputest/cpputest.git
cd
cpputest
mkdir cpputest_build
cmake -B cpputest_build
cmake --build cpputest_build
Then to get started, you'll need to do the following:
Add the include path to the Makefile. Something like:
CPPFLAGS += -I$(CPPUTEST_HOME)/include
Add the memory leak macros to your Makefile (needed for additional debug info!). Something like:
CXXFLAGS += -include $(CPPUTEST_HOME)/include/CppUTest/MemoryLeakDetectorNewMacros.h
CFLAGS += -include $(CPPUTEST_HOME)/include/CppUTest/MemoryLeakDetectorMallocMacros.h
Add the library linking to your Makefile. Something like:
LD_LIBRARIES = -L$(CPPUTEST_HOME)/lib -lCppUTest -lCppUTestExt
After this, you can write your first test:
TEST_GROUP
(FirstTestGroup)
{
};
TEST
(FirstTestGroup, FirstTest)
{
FAIL
(
""
Fail me!
""
);
}
You can build and install cpputest using
vcpkg
dependency manager:
$
vcpkg install cpputest (More information: https://github.com/microsoft/vcpkg)
Command line switches
-h
help, shows the latest help, including the parameters we've implemented after updating this README page.
-v
verbose, print each test name as it runs
-r#
repeat the tests some number of times, default is one, default if # is not specified is 2. This is handy if you are experiencing memory leaks related to statics and caches.
-s#
random shuffle the test execution order. # is an integer used for seeding the random number generator. # is optional, and if omitted, the seed value is chosen automatically, which results in a different order every time. The seed value is printed to console to make it possible to reproduce a previously generated execution order. Handy for detecting problems related to dependencies between tests.
-g
group only run test whose group contains the substring group
-n
name only run test whose name contains the substring name
-f
crash on fail, run the tests as normal but, when a test fails, crash rather than report the failure in the normal way
Test Macros
TEST(group, name)
- define a test
IGNORE_TEST(group, name)
- turn off the execution of a test
TEST_GROUP(group)
- Declare a test group to which certain tests belong. This will also create the link needed from another library.
TEST_GROUP_BASE(group, base)
- Same as
TEST_GROUP
, just use a different base class than Utest
TEST_SETUP()
- Declare a void setup method in a
TEST_GROUP
- this is the same as declaring void
setup()
TEST_TEARDOWN()
- Declare a void setup method in a
TEST_GROUP
IMPORT_TEST_GROUP(group)
- Export the name of a test group so it can be linked in from a library. Needs to be done in
main
.
Set up and tear down support
Each
TEST_GROUP
may contain a
setup
and/or a
teardown
method.
setup()
is called prior to each
TEST
body and
teardown()
is called after the test body.
Assertion Macros
The failure of one of these macros causes the current test to immediately exit
CHECK(boolean condition)
- checks any boolean result
CHECK_TRUE(boolean condition)
- checks for true
CHECK_FALSE(boolean condition)
- checks for false
CHECK_EQUAL(expected, actual)
- checks for equality between entities using
==
. So if you have a class that supports
operator==()
you can use this macro to compare two instances.
STRCMP_EQUAL(expected, actual)
- check const
char*
strings for equality using
strcmp
LONGS_EQUAL(expected, actual)
- Compares two numbers
BYTES_EQUAL(expected, actual)
- Compares two numbers, eight bits wide
POINTERS_EQUAL(expected, actual)
- Compares two
const void *
DOUBLES_EQUAL(expected, actual, tolerance)
- Compares two doubles within some tolerance
ENUMS_EQUAL_INT(excepted, actual)
- Compares two enums which their underlying type is
int
ENUMS_EQUAL_TYPE(underlying_type, excepted, actual)
- Compares two enums which they have the same underlying type
FAIL(text)
- always fails
TEST_EXIT
- Exit the test without failure - useful for contract testing (implementing an assert fake)
Customize
CHECK_EQUAL
to work with your types that support
operator==()
Create the function:
SimpleString StringFrom(const yourType&)
The Extensions directory has a few of these.
Building default checks with TestPlugin
CppUTest can support extra checking functionality by inserting TestPlugins
TestPlugin is derived from the TestPlugin class and can be inserted in the TestRegistry via the installPlugin method.
TestPlugins can be used for, for example, system stability and resource handling like files, memory or network connection clean-up.
In CppUTest, the memory leak detection is done via a default enabled TestPlugin
Example of a main with a TestPlugin:
int
main
(
int
ac,
char
** av)
{
LogPlugin logPlugin;
TestRegistry::getCurrentRegistry
()->
installPlugin
(&logPlugin);
int
result =
CommandLineTestRunner::RunAllTests
(ac, av);
TestRegistry::getCurrentRegistry
()->
resetPlugins
();
return
result;
}
Memory leak detection
A platform specific memory leak detection mechanism is provided.
If a test fails and has allocated memory prior to the fail and that memory is not cleaned up by TearDown, a memory leak is reported.
It is best to only chase memory leaks when other errors have been eliminated.
Some code uses lazy initialization and appears to leak when it really does not (for example: gcc stringstream used to in an earlier release). One cause is that some standard library calls allocate something and do not free it until after
main
(or never).
To find out if a memory leak is due to lazy initialization set the
-r
switch to run tests twice. The signature of this situation is that the first run shows leaks and the second run shows no leaks. When both runs show leaks, you have a leak to find.
How is memory leak detection implemented?
Before
setup()
a memory usage checkpoint is recorded
After
teardown()
another checkpoint is taken and compared to the original checkpoint
In Visual Studio the MS debug heap capabilities are used
For GCC a simple new/delete count is used in overridden operators
new
,
new[]
,
delete
and
delete[]
If you use some leaky code that you can't or won't fix you can tell a TEST to ignore a certain number of leaks as in this example:
TEST
(MemoryLeakWarningTest, Ignore1)
{
EXPECT_N_LEAKS
(
1
);
char
* arrayToLeak1 =
new
char
[
100
];
}
Example Main
#
include
""
CppUTest/CommandLineTestRunner.h
""
int
main
(
int
ac,
char
** av)
{
return
RUN_ALL_TESTS
(ac, av);
}
Example Test
#
include
""
CppUTest/TestHarness.h
""
#
include
""
ClassName.h
""
TEST_GROUP
(ClassName)
{
ClassName* className;
void
setup
()
{
className =
new
ClassName
();
}
void
teardown
()
{
delete
className;
}
};
TEST
(ClassName, Create)
{
CHECK
(
0
!= className);
CHECK
(
true
);
CHECK_EQUAL
(
1
,
1
);
LONGS_EQUAL
(
1
,
1
);
DOUBLES_EQUAL
(
1.000
,
1.001
, .
01
);
STRCMP_EQUAL
(
""
hello
""
,
""
hello
""
);
FAIL
(
""
The prior tests pass, but this one doesn't
""
);
}
There are some scripts that are helpful in creating your initial h, cpp, and
Test files. See scripts/README.TXT
Conan
CppUTest is available through
conan-center
.
conanfile.txt
[requires]
cpputest/4.0
[generators]
cmake_find_package
cmake_paths
CMake
find_package
(CppUTest REQUIRED)
add_executable
(example_test ExampleTest.cpp)
target_link_libraries
(example_test
PRIVATE
CppUTest::CppUTest
CppUTest::CppUTestExt)
Integration as external CMake project
Sometimes you want to use CppUTest in your project without installing it to your system or for having control over the version you are using. This little snippet get the wanted version from GitHub and builds it as a library.
# CppUTest
include
(FetchContent)
FetchContent_Declare(
CppUTest
GIT_REPOSITORY https://github.com/cpputest/cpputest.git
GIT_TAG        master
# or use release tag, eg. v4.0
)
# Set this to ON if you want to have the CppUTests in your project as well.
set
(TESTS
OFF
CACHE
BOOL
""Switch off CppUTest Test build""
)
FetchContent_MakeAvailable(CppUTest)
It can be used then like so:
add_executable
(run_tests UnitTest1.cpp UnitTest2.cpp)
target_link_libraries
(example_test
PRIVATE
CppUTest::CppUTest
CppUTest::CppUTestExt)
About
CppUTest unit testing and mocking framework for C/C++
cpputest.github.io
Topics
c-plus-plus
unit-testing
test-driven-development
cpputest
very-kewl
memory-leak
mocking-framework
Resources
Readme
License
BSD-3-Clause license
Activity
Custom properties
Stars
1.4k
stars
Watchers
87
watching
Forks
516
forks
Report repository
Releases
7
Latest passing build
Latest
Apr 23, 2020
+ 6 releases
Packages
0
No packages published
Contributors
119
+ 105 contributors
Languages
C++
82.8%
C
4.0%
M4
4.0%
Makefile
3.7%
CMake
2.4%
Shell
1.3%
Other
1.8%

cpputest
/
cpputest
Public
Notifications
You must be signed in to change notification settings
Fork
516
Star
1.4k
Code
Issues
168
Pull requests
19
Discussions
Actions
Projects
0
Security
Insights
Additional navigation options
Code
Issues
Pull requests
Discussions
Actions
Projects
Security
Insights
Files
master
Breadcrumbs
cpputest
/
tests
/
CppUTest
/
MemoryLeakDetectorTest.cpp
Blame
Blame
Latest commit
History
History
692 lines (606 loc) · 25.4 KB
master
Breadcrumbs
cpputest
/
tests
/
CppUTest
/
MemoryLeakDetectorTest.cpp
Top
File metadata and controls
Code
Blame
692 lines (606 loc) · 25.4 KB
Raw
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
/*
* Copyright (c) 2007, Michael Feathers, James Grenning and Bas Vodde
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the <organization> nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE EARLIER MENTIONED AUTHORS ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL <copyright holder> BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#
include
""
CppUTest/TestHarness.h
""
#
include
""
CppUTest/MemoryLeakDetector.h
""
#
include
""
CppUTest/TestMemoryAllocator.h
""
#
include
""
CppUTest/PlatformSpecificFunctions.h
""
class
MemoryLeakFailureForTest
:
public
MemoryLeakFailure
{
public:
virtual
~MemoryLeakFailureForTest
() CPPUTEST_DESTRUCTOR_OVERRIDE
{
}
virtual
void
fail
(
char
* fail_string) CPPUTEST_OVERRIDE
{
*message = fail_string;
}
SimpleString *message;
};
class
NewAllocatorForMemoryLeakDetectionTest
:
public
TestMemoryAllocator
{
public:
NewAllocatorForMemoryLeakDetectionTest
() :
TestMemoryAllocator
(
""
Standard New Allocator
""
,
""
new
""
,
""
delete
""
),
alloc_called
(
0
), free_called(
0
)
{
}
int
alloc_called;
int
free_called;
char
*
alloc_memory
(
size_t
size,
const
char
*,
size_t
) CPPUTEST_OVERRIDE
{
alloc_called++;
return
TestMemoryAllocator::alloc_memory
(size,
""
file
""
,
1
);
}
void
free_memory
(
char
* memory,
size_t
size,
const
char
* file,
size_t
line) CPPUTEST_OVERRIDE
{
free_called++;
TestMemoryAllocator::free_memory
(memory, size, file, line);
}
};
class
AllocatorForMemoryLeakDetectionTest
:
public
TestMemoryAllocator
{
public:
AllocatorForMemoryLeakDetectionTest
() :
alloc_called
(
0
), free_called(
0
), allocMemoryLeakNodeCalled(
0
), freeMemoryLeakNodeCalled(
0
)
{
}
int
alloc_called;
int
free_called;
int
allocMemoryLeakNodeCalled;
int
freeMemoryLeakNodeCalled;
char
*
alloc_memory
(
size_t
size,
const
char
* file,
size_t
line) CPPUTEST_OVERRIDE
{
alloc_called++;
return
TestMemoryAllocator::alloc_memory
(size, file, line);
}
void
free_memory
(
char
* memory,
size_t
size,
const
char
* file,
size_t
line) CPPUTEST_OVERRIDE
{
free_called++;
TestMemoryAllocator::free_memory
(memory, size, file, line);
}
char
*
allocMemoryLeakNode
(
size_t
size) CPPUTEST_OVERRIDE
{
allocMemoryLeakNodeCalled++;
return
TestMemoryAllocator::alloc_memory
(size, __FILE__, __LINE__);
}
void
freeMemoryLeakNode
(
char
* memory) CPPUTEST_OVERRIDE
{
freeMemoryLeakNodeCalled++;
TestMemoryAllocator::free_memory
(memory,
0
,  __FILE__, __LINE__);
}
};
TEST_GROUP
(MemoryLeakDetectorTest)
{
MemoryLeakDetector* detector;
MemoryLeakFailureForTest *reporter;
AllocatorForMemoryLeakDetectionTest* testAllocator;
void
setup
() CPPUTEST_OVERRIDE
{
reporter =
new
MemoryLeakFailureForTest;
detector =
new
MemoryLeakDetector
(reporter);
testAllocator =
new
AllocatorForMemoryLeakDetectionTest;
detector->
enable
();
detector->
startChecking
();
reporter->
message
=
new
SimpleString
();
}
void
teardown
() CPPUTEST_OVERRIDE
{
delete
reporter->
message
;
delete
detector;
delete
reporter;
delete
testAllocator;
}
};
TEST
(MemoryLeakDetectorTest, OneLeak)
{
char
* mem = detector->
allocMemory
(testAllocator,
3
);
detector->
stopChecking
();
SimpleString output = detector->
report
(mem_leak_period_checking);
STRCMP_CONTAINS
(
""
Memory leak(s) found
""
, output.
asCharString
());
STRCMP_CONTAINS
(
""
size: 3
""
, output.
asCharString
());
STRCMP_CONTAINS
(
""
alloc
""
, output.
asCharString
());
STRCMP_CONTAINS
(
StringFromFormat
(
""
%p
""
, (
void
*) mem).
asCharString
(), output.
asCharString
());
STRCMP_CONTAINS
(
""
Total number of leaks
""
, output.
asCharString
());
PlatformSpecificFree
(mem);
LONGS_EQUAL
(
1
, testAllocator->
alloc_called
);
LONGS_EQUAL
(
0
, testAllocator->
free_called
);
}
TEST
(MemoryLeakDetectorTest, sequenceNumbersOfMemoryLeaks)
{
char
* mem = detector->
allocMemory
(
defaultNewAllocator
(),
1
);
char
* mem2 = detector->
allocMemory
(
defaultNewAllocator
(),
2
);
char
* mem3 = detector->
allocMemory
(
defaultNewAllocator
(),
3
);
SimpleString output = detector->
report
(mem_leak_period_checking);
STRCMP_CONTAINS
(
""
Alloc num (1)
""
, output.
asCharString
());
STRCMP_CONTAINS
(
""
Alloc num (2)
""
, output.
asCharString
());
STRCMP_CONTAINS
(
""
Alloc num (3)
""
, output.
asCharString
());
PlatformSpecificFree
(mem);
PlatformSpecificFree
(mem2);
PlatformSpecificFree
(mem3);
}
TEST
(MemoryLeakDetectorTest, memoryDumpOutput)
{
char
* mem = detector->
allocMemory
(
defaultNewAllocator
(),
6
);
SimpleString::StrNCpy
(mem,
""
test1
""
,
6
);
SimpleString output = detector->
report
(mem_leak_period_checking);
STRCMP_CONTAINS
(
""
Alloc num (1)
""
, output.
asCharString
());
STRCMP_CONTAINS
(
""
Leak size: 6 Allocated at
""
,  output.
asCharString
());
STRCMP_CONTAINS
(
""
Content:
""
,  output.
asCharString
());
STRCMP_CONTAINS
(
""
0000: 74 65 73 74 31 00                                |test1.|
""
, output.
asCharString
());
PlatformSpecificFree
(mem);
}
TEST
(MemoryLeakDetectorTest, OneHundredLeaks)
{
const
int
amount_alloc =
100
;
char
*mem[amount_alloc];
for
(
int
i =
0
; i < amount_alloc; i++)
mem[i] = detector->
allocMemory
(
defaultMallocAllocator
(),
3
);
detector->
stopChecking
();
SimpleString output = detector->
report
(mem_leak_period_checking);
STRCMP_CONTAINS
(
""
Memory leak(s) found
""
, output.
asCharString
());
STRCMP_CONTAINS
(
""
Total number of leaks
""
, output.
asCharString
());
STRCMP_CONTAINS
(
""
Memory leak reports about malloc and free
""
, output.
asCharString
());
//
don't reuse i for vc6 compatibility
for
(
int
j =
0
; j < amount_alloc; j++)
PlatformSpecificFree
(mem[j]);
}
TEST
(MemoryLeakDetectorTest, OneLeakOutsideCheckingPeriod)
{
detector->
stopChecking
();
char
* mem = detector->
allocMemory
(
defaultNewAllocator
(),
4
);
SimpleString output = detector->
report
(mem_leak_period_all);
CHECK
(output.
contains
(
""
Memory leak(s) found
""
));
CHECK
(output.
contains
(
""
size: 4
""
));
CHECK
(output.
contains
(
""
new
""
));
CHECK
(output.
contains
(
""
Total number of leaks
""
));
PlatformSpecificFree
(mem);
}
TEST
(MemoryLeakDetectorTest, NoLeaksWhatsoever)
{
detector->
stopChecking
();
STRCMP_CONTAINS
(
""
No memory leaks
""
, detector->
report
(mem_leak_period_checking));
STRCMP_CONTAINS
(
""
No memory leaks
""
, detector->
report
(mem_leak_period_all));
}
TEST
(MemoryLeakDetectorTest, TwoLeaksUsingOperatorNew)
{
char
* mem = detector->
allocMemory
(
defaultNewAllocator
(),
4
);
char
* mem2 = detector->
allocMemory
(
defaultNewAllocator
(),
8
);
detector->
stopChecking
();
SimpleString output = detector->
report
(mem_leak_period_checking);
LONGS_EQUAL
(
2
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
CHECK
(output.
contains
(
""
size: 8
""
));
CHECK
(output.
contains
(
""
size: 4
""
));
PlatformSpecificFree
(mem);
PlatformSpecificFree
(mem2);
}
TEST
(MemoryLeakDetectorTest, OneAllocButNoLeak)
{
char
* mem = detector->
allocMemory
(testAllocator,
4
);
detector->
deallocMemory
(testAllocator, mem);
detector->
stopChecking
();
STRCMP_CONTAINS
(
""
No memory leaks
""
, detector->
report
(mem_leak_period_checking));
LONGS_EQUAL
(
1
, testAllocator->
alloc_called
);
LONGS_EQUAL
(
1
, testAllocator->
free_called
);
}
TEST
(MemoryLeakDetectorTest, TwoAllocOneFreeOneLeak)
{
char
* mem = detector->
allocMemory
(testAllocator,
4
);
char
* mem2 = detector->
allocMemory
(testAllocator,
12
);
detector->
deallocMemory
(testAllocator, mem);
detector->
stopChecking
();
SimpleString output = detector->
report
(mem_leak_period_checking);
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
CHECK
(output.
contains
(
""
Leak size: 12
""
));
CHECK
(!output.
contains
(
""
Leak size: 4
""
));
PlatformSpecificFree
(mem2);
LONGS_EQUAL
(
2
, testAllocator->
alloc_called
);
LONGS_EQUAL
(
1
, testAllocator->
free_called
);
}
TEST
(MemoryLeakDetectorTest, TwoAllocOneFreeOneLeakReverseOrder)
{
char
* mem = detector->
allocMemory
(
defaultNewAllocator
(),
4
);
char
* mem2 = detector->
allocMemory
(
defaultNewAllocator
(),
12
);
detector->
deallocMemory
(
defaultNewAllocator
(), mem2);
detector->
stopChecking
();
SimpleString output = detector->
report
(mem_leak_period_checking);
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
CHECK
(!output.
contains
(
""
size: 12
""
));
CHECK
(output.
contains
(
""
size: 4
""
));
PlatformSpecificFree
(mem);
}
TEST
(MemoryLeakDetectorTest, DeleteNonAlocatedMemory)
{
char
a;
char
* pa = &a;
detector->
deallocMemory
(
defaultMallocAllocator
(), pa,
""
FREE.c
""
,
100
);
detector->
stopChecking
();
CHECK
(reporter->
message
->
contains
(
""
Deallocating non-allocated memory
""
));
CHECK
(reporter->
message
->
contains
(
""
allocated at file: <unknown> line: 0 size: 0 type: unknown
""
));
CHECK
(reporter->
message
->
contains
(
""
deallocated at file: FREE.c line: 100 type: free
""
));
}
TEST
(MemoryLeakDetectorTest, IgnoreMemoryAllocatedOutsideCheckingPeriod)
{
detector->
stopChecking
();
char
* mem = detector->
allocMemory
(
defaultNewAllocator
(),
4
);
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_all));
detector->
deallocMemory
(
defaultNewAllocator
(), mem);
}
TEST
(MemoryLeakDetectorTest, IgnoreMemoryAllocatedOutsideCheckingPeriodComplicatedCase)
{
char
* mem = detector->
allocMemory
(
defaultNewAllocator
(),
4
);
detector->
stopChecking
();
char
* mem2 = detector->
allocMemory
(
defaultNewAllocator
(),
8
);
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
detector->
clearAllAccounting
(mem_leak_period_checking);
PlatformSpecificFree
(mem);
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_all));
detector->
startChecking
();
char
* mem3 = detector->
allocMemory
(
defaultNewAllocator
(),
4
);
detector->
stopChecking
();
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
LONGS_EQUAL
(
2
, detector->
totalMemoryLeaks
(mem_leak_period_all));
detector->
clearAllAccounting
(mem_leak_period_checking);
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_all));
detector->
clearAllAccounting
(mem_leak_period_all);
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_all));
PlatformSpecificFree
(mem2);
PlatformSpecificFree
(mem3);
}
TEST
(MemoryLeakDetectorTest, OneLeakUsingOperatorNewWithFileLine)
{
char
* mem = detector->
allocMemory
(
defaultNewAllocator
(),
4
,
""
file.cpp
""
,
1234
);
detector->
stopChecking
();
SimpleString output = detector->
report
(mem_leak_period_checking);
CHECK
(output.
contains
(
""
file.cpp
""
));
CHECK
(output.
contains
(
""
1234
""
));
PlatformSpecificFree
(mem);
}
TEST
(MemoryLeakDetectorTest, OneAllocAndFreeUsingArrayNew)
{
char
* mem = detector->
allocMemory
(
defaultNewArrayAllocator
(),
10
,
""
file.cpp
""
,
1234
);
char
* mem2 = detector->
allocMemory
(
defaultNewArrayAllocator
(),
12
);
LONGS_EQUAL
(
2
, detector->
totalMemoryLeaks
(mem_leak_period_all));
SimpleString output = detector->
report
(mem_leak_period_checking);
CHECK
(output.
contains
(
""
new []
""
));
detector->
deallocMemory
(
defaultNewArrayAllocator
(), mem);
detector->
deallocMemory
(
defaultNewArrayAllocator
(), mem2);
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_all));
detector->
stopChecking
();
}
TEST
(MemoryLeakDetectorTest, OneAllocAndFree)
{
char
* mem = detector->
allocMemory
(
defaultMallocAllocator
(),
10
,
""
file.cpp
""
,
1234
);
char
* mem2 = detector->
allocMemory
(
defaultMallocAllocator
(),
12
);
LONGS_EQUAL
(
2
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
SimpleString output = detector->
report
(mem_leak_period_checking);
CHECK
(output.
contains
(
""
malloc
""
));
detector->
deallocMemory
(
defaultMallocAllocator
(), mem);
detector->
deallocMemory
(
defaultMallocAllocator
(), mem2,
""
file.c
""
,
5678
);
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_all));
detector->
stopChecking
();
}
TEST
(MemoryLeakDetectorTest, OneRealloc)
{
char
* mem1 = detector->
allocMemory
(testAllocator,
10
,
""
file.cpp
""
,
1234
,
true
);
char
* mem2 = detector->
reallocMemory
(testAllocator, mem1,
1000
,
""
other.cpp
""
,
5678
,
true
);
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
SimpleString output = detector->
report
(mem_leak_period_checking);
CHECK
(output.
contains
(
""
other.cpp
""
));
detector->
deallocMemory
(testAllocator, mem2,
true
);
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_all));
detector->
stopChecking
();
LONGS_EQUAL
(
1
, testAllocator->
alloc_called
);
LONGS_EQUAL
(
1
, testAllocator->
free_called
);
LONGS_EQUAL
(
2
, testAllocator->
allocMemoryLeakNodeCalled
);
LONGS_EQUAL
(
2
, testAllocator->
freeMemoryLeakNodeCalled
);
}
TEST
(MemoryLeakDetectorTest, ReallocNonAllocatedMemory)
{
char
mem1;
char
* mem2 = detector->
reallocMemory
(testAllocator, &mem1,
5
,
""
other.cpp
""
,
13
,
true
);
detector->
deallocMemory
(testAllocator, mem2,
true
);
detector->
stopChecking
();
CHECK
(reporter->
message
->
contains
(
""
Deallocating non-allocated memory
\n
""
));
CHECK
(reporter->
message
->
contains
(
""
deallocated at file: other.cpp line: 13
""
));
}
TEST
(MemoryLeakDetectorTest, AllocOneTypeFreeAnotherType)
{
char
* mem = detector->
allocMemory
(
defaultNewArrayAllocator
(),
100
,
""
ALLOC.c
""
,
10
);
detector->
deallocMemory
(
defaultMallocAllocator
(), mem,
""
FREE.c
""
,
100
);
detector->
stopChecking
();
CHECK
(reporter->
message
->
contains
(
""
Allocation/deallocation type mismatch
""
));
CHECK
(reporter->
message
->
contains
(
""
allocated at file: ALLOC.c line: 10 size: 100 type: new []
""
));
CHECK
(reporter->
message
->
contains
(
""
deallocated at file: FREE.c line: 100 type: free
""
));
}
TEST
(MemoryLeakDetectorTest, AllocOneTypeFreeAnotherTypeWithCheckingDisabled)
{
detector->
disableAllocationTypeChecking
();
char
* mem = detector->
allocMemory
(
defaultNewArrayAllocator
(),
100
,
""
ALLOC.c
""
,
10
);
detector->
deallocMemory
(
defaultNewAllocator
(), mem,
""
FREE.c
""
,
100
);
detector->
stopChecking
();
STRCMP_EQUAL
(
""
""
, reporter->
message
->
asCharString
());
detector->
enableAllocationTypeChecking
();
}
TEST
(MemoryLeakDetectorTest, mallocLeakGivesAdditionalWarning)
{
char
* mem = detector->
allocMemory
(
defaultMallocAllocator
(),
100
,
""
ALLOC.c
""
,
10
);
detector->
stopChecking
();
SimpleString output = detector->
report
(mem_leak_period_checking);
STRCMP_CONTAINS
(
""
Memory leak reports about malloc and free can be caused by allocating using the cpputest version of malloc
""
, output.
asCharString
());
PlatformSpecificFree
(mem);
}
TEST
(MemoryLeakDetectorTest, newLeakDoesNotGiveAdditionalWarning)
{
char
* mem = detector->
allocMemory
(
defaultNewAllocator
(),
100
,
""
ALLOC.c
""
,
10
);
detector->
stopChecking
();
SimpleString output = detector->
report
(mem_leak_period_checking);
CHECK
(! output.
contains
(
""
Memory leak reports about malloc and free
""
));
PlatformSpecificFree
(mem);
}
TEST
(MemoryLeakDetectorTest, MarkCheckingPeriodLeaksAsNonCheckingPeriod)
{
char
* mem = detector->
allocMemory
(
defaultNewArrayAllocator
(),
100
);
char
* mem2 = detector->
allocMemory
(
defaultNewArrayAllocator
(),
100
);
detector->
stopChecking
();
LONGS_EQUAL
(
2
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
LONGS_EQUAL
(
2
, detector->
totalMemoryLeaks
(mem_leak_period_all));
detector->
markCheckingPeriodLeaksAsNonCheckingPeriod
();
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
LONGS_EQUAL
(
2
, detector->
totalMemoryLeaks
(mem_leak_period_all));
PlatformSpecificFree
(mem);
PlatformSpecificFree
(mem2);
}
TEST
(MemoryLeakDetectorTest, memoryCorruption)
{
char
* mem = detector->
allocMemory
(
defaultMallocAllocator
(),
10
,
""
ALLOC.c
""
,
10
);
mem[
10
] =
'
O
'
;
mem[
11
] =
'
H
'
;
detector->
deallocMemory
(
defaultMallocAllocator
(), mem,
""
FREE.c
""
,
100
);
detector->
stopChecking
();
CHECK
(reporter->
message
->
contains
(
""
Memory corruption
""
));
CHECK
(reporter->
message
->
contains
(
""
allocated at file: ALLOC.c line: 10 size: 10 type: malloc
""
));
CHECK
(reporter->
message
->
contains
(
""
deallocated at file: FREE.c line: 100 type: free
""
));
}
TEST
(MemoryLeakDetectorTest, safelyDeleteNULL)
{
detector->
deallocMemory
(
defaultNewAllocator
(), NULLPTR);
STRCMP_EQUAL
(
""
""
, reporter->
message
->
asCharString
());
}
TEST
(MemoryLeakDetectorTest, periodDisabled)
{
detector->
disable
();
char
* mem = detector->
allocMemory
(
defaultMallocAllocator
(),
2
);
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_all));
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_disabled));
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_enabled));
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
detector->
deallocMemory
(
defaultMallocAllocator
(), mem);
}
TEST
(MemoryLeakDetectorTest, periodEnabled)
{
detector->
enable
();
char
* mem = detector->
allocMemory
(
defaultMallocAllocator
(),
2
);
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_all));
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_disabled));
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_enabled));
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
detector->
deallocMemory
(
defaultMallocAllocator
(), mem);
}
TEST
(MemoryLeakDetectorTest, periodChecking)
{
char
* mem = detector->
allocMemory
(
defaultMallocAllocator
(),
2
);
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_all));
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_disabled));
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_enabled));
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_checking));
detector->
deallocMemory
(
defaultMallocAllocator
(), mem);
}
TEST
(MemoryLeakDetectorTest, defaultAllocationStageIsZero)
{
LONGS_EQUAL
(
0
, detector->
getCurrentAllocationStage
());
}
TEST
(MemoryLeakDetectorTest, canFreeNoAllocations)
{
detector->
deallocAllMemoryInCurrentAllocationStage
();
LONGS_EQUAL
(
0
, detector->
getCurrentAllocationStage
());
}
TEST
(MemoryLeakDetectorTest, increaseAllocationStage)
{
detector->
increaseAllocationStage
();
LONGS_EQUAL
(
1
, detector->
getCurrentAllocationStage
());
}
TEST
(MemoryLeakDetectorTest, decreaseAllocationStage)
{
detector->
increaseAllocationStage
();
detector->
decreaseAllocationStage
();
LONGS_EQUAL
(
0
, detector->
getCurrentAllocationStage
());
}
TEST
(MemoryLeakDetectorTest, freeAllMemoryInCurrentAllocationStage)
{
detector->
increaseAllocationStage
();
detector->
allocMemory
(
defaultMallocAllocator
(),
2
);
detector->
allocMemory
(
defaultMallocAllocator
(),
2
);
detector->
deallocAllMemoryInCurrentAllocationStage
();
LONGS_EQUAL
(
0
, detector->
totalMemoryLeaks
(mem_leak_period_all));
}
TEST
(MemoryLeakDetectorTest, freeOnlyTheMemoryInTheAllocationStage)
{
char
* mem = detector->
allocMemory
(
defaultMallocAllocator
(),
2
);
detector->
increaseAllocationStage
();
detector->
allocMemory
(
defaultMallocAllocator
(),
2
);
detector->
deallocAllMemoryInCurrentAllocationStage
();
LONGS_EQUAL
(
1
, detector->
totalMemoryLeaks
(mem_leak_period_all));
detector->
deallocMemory
(
defaultMallocAllocator
(), mem);
}
TEST
(MemoryLeakDetectorTest, allocateWithANullAllocatorCausesNoProblems)
{
char
* mem = detector->
allocMemory
(
NullUnknownAllocator::defaultAllocator
(),
2
);
detector->
deallocMemory
(
NullUnknownAllocator::defaultAllocator
(), mem);
}
TEST
(MemoryLeakDetectorTest, invalidateMemory)
{
unsigned
char
* mem = (
unsigned
char
*)detector->
allocMemory
(
defaultMallocAllocator
(),
2
);
detector->
invalidateMemory
((
char
*)mem);
CHECK
(mem[
0
] ==
0xCD
);
CHECK
(mem[
1
] ==
0xCD
);
detector->
deallocMemory
(
defaultMallocAllocator
(), mem);
}
TEST
(MemoryLeakDetectorTest, invalidateMemoryNULLShouldWork)
{
detector->
invalidateMemory
(NULLPTR);
}
TEST_GROUP
(MemoryLeakDetectorListTest)
{
};
TEST
(MemoryLeakDetectorListTest, clearAllAccountingIsWorkingProperly)
{
MemoryLeakDetectorList listForTesting;
MemoryLeakDetectorNode node1, node2, node3;
node3.
period_
= mem_leak_period_disabled;
listForTesting.
addNewNode
(&node1);
listForTesting.
addNewNode
(&node2);
listForTesting.
addNewNode
(&node3);
listForTesting.
clearAllAccounting
(mem_leak_period_enabled);
POINTERS_EQUAL
(NULLPTR, listForTesting.
getFirstLeak
(mem_leak_period_enabled));
CHECK
(&node3 == listForTesting.
getFirstLeak
(mem_leak_period_disabled));
}
TEST_GROUP
(SimpleStringBuffer)
{
};
TEST
(SimpleStringBuffer, initialStringIsEmpty)
{
SimpleStringBuffer buffer;
STRCMP_EQUAL
(
""
""
, buffer.
toString
());
}
TEST
(SimpleStringBuffer, simpleTest)
{
SimpleStringBuffer buffer;
buffer.
add
(
""
Hello
""
);
buffer.
add
(
""
World
""
);
STRCMP_EQUAL
(
""
Hello World
""
, buffer.
toString
());
}
TEST
(SimpleStringBuffer, writePastLimit)
{
SimpleStringBuffer buffer;
for
(
int
i =
0
; i < SimpleStringBuffer::SIMPLE_STRING_BUFFER_LEN *
2
; i++)
buffer.
add
(
""
h
""
);
SimpleString
str
(
""
h
""
, SimpleStringBuffer::SIMPLE_STRING_BUFFER_LEN-
1
);
STRCMP_EQUAL
(str.
asCharString
(), buffer.
toString
());
}
TEST
(SimpleStringBuffer, setWriteLimit)
{
SimpleStringBuffer buffer;
buffer.
setWriteLimit
(
10
);
for
(
int
i =
0
; i < SimpleStringBuffer::SIMPLE_STRING_BUFFER_LEN ; i++)
buffer.
add
(
""
h
""
);
SimpleString
str
(
""
h
""
,
10
);
STRCMP_EQUAL
(str.
asCharString
(), buffer.
toString
());
}
TEST
(SimpleStringBuffer, setWriteLimitTooHighIsIgnored)
{
SimpleStringBuffer buffer;
buffer.
setWriteLimit
(SimpleStringBuffer::SIMPLE_STRING_BUFFER_LEN+
10
);
for
(
int
i =
0
; i < SimpleStringBuffer::SIMPLE_STRING_BUFFER_LEN+
10
; i++)
buffer.
add
(
""
h
""
);
SimpleString
str
(
""
h
""
, SimpleStringBuffer::SIMPLE_STRING_BUFFER_LEN-
1
);
STRCMP_EQUAL
(str.
asCharString
(), buffer.
toString
());
}
TEST
(SimpleStringBuffer, resetWriteLimit)
{
SimpleStringBuffer buffer;
buffer.
setWriteLimit
(
10
);
for
(
int
i =
0
; i < SimpleStringBuffer::SIMPLE_STRING_BUFFER_LEN ; i++)
buffer.
add
(
""
h
""
);
buffer.
resetWriteLimit
();
buffer.
add
(
""
%s
""
,
SimpleString
(
""
h
""
,
10
).
asCharString
());
SimpleString
str
(
""
h
""
,
20
);
STRCMP_EQUAL
(str.
asCharString
(), buffer.
toString
());
}
TEST
(SimpleStringBuffer, addMemoryDumpOneLinePlusOnePartial)
{
SimpleStringBuffer buffer;
buffer.
addMemoryDump
(
""
deadbeefdeadbeefhopsxx
""
,
22
);
STRCMP_EQUAL
(
""
0000: 64 65 61 64 62 65 65 66  64 65 61 64 62 65 65 66 |deadbeefdeadbeef|
\n
""
""
0010: 68 6f 70 73 78 78                                |hopsxx|
\n
""
,
buffer.
toString
());
}
TEST
(SimpleStringBuffer, addMemoryDumpNonPrintable)
{
SimpleStringBuffer buffer;
//
Ensure we test edge cases - NUL, 0x1F, 0x7F, 0xFF
buffer.
addMemoryDump
(
""
\x15\x7f\xff\x00\x1f
tdd
""
,
8
);
STRCMP_EQUAL
(
""
0000: 15 7f ff 00 1f 74 64 64                          |.....tdd|
\n
""
,
buffer.
toString
());
}
TEST
(SimpleStringBuffer, addMemoryDumpOneLine)
{
SimpleStringBuffer buffer;
buffer.
addMemoryDump
(
""
deadbeefdeadbeef
""
,
16
);
STRCMP_EQUAL
(
""
0000: 64 65 61 64 62 65 65 66  64 65 61 64 62 65 65 66 |deadbeefdeadbeef|
\n
""
,
buffer.
toString
());
}
TEST
(SimpleStringBuffer, addMemoryDumpOneHalfLine)
{
SimpleStringBuffer buffer;
buffer.
addMemoryDump
(
""
deadbeef
""
,
8
);
STRCMP_EQUAL
(
""
0000: 64 65 61 64 62 65 65 66                          |deadbeef|
\n
""
,
buffer.
toString
());
}
TEST
(SimpleStringBuffer, addMemoryDumpOneByte)
{
SimpleStringBuffer buffer;
buffer.
addMemoryDump
(
""
Z
""
,
1
);
STRCMP_EQUAL
(
""
0000: 5a                                               |Z|
\n
""
,
buffer.
toString
());
}
TEST
(SimpleStringBuffer, addMemoryDumpZeroBytes)
{
SimpleStringBuffer buffer;
buffer.
addMemoryDump
(
""
""
,
0
);
STRCMP_EQUAL
(
""
""
, buffer.
toString
());
}
TEST_GROUP
(ReallocBugReported)
{
MemoryLeakFailureForTest reporter;
};
TEST
(ReallocBugReported, CanSafelyDoAReallocWithANewAllocator)
{
MemoryLeakDetector
detector
(&reporter);
char
* mem = detector.
allocMemory
(
defaultNewAllocator
(),
5
,
""
file
""
,
1
);
mem = detector.
reallocMemory
(
defaultNewAllocator
(), mem,
19
,
""
file
""
,
1
);
detector.
deallocMemory
(
defaultNewAllocator
(), mem);
}
TEST
(ReallocBugReported, CanSafelyDoAReallocWithAMallocAllocator)
{
MemoryLeakDetector
detector
(&reporter);
char
* mem = detector.
allocMemory
(
defaultMallocAllocator
(),
5
,
""
file
""
,
1
,
true
);
mem = detector.
reallocMemory
(
defaultMallocAllocator
(), mem,
19
,
""
file
""
,
1
,
true
);
detector.
deallocMemory
(
defaultMallocAllocator
(), mem,
true
);
}

Services ▼
Training
Coaching and Consulting
Workshops
Contact ▼
Contact
Join our mailing list
About
Resources ▼
Blog
Papers and Presentation
-- Titles
-- Titles & Synopsis
Stories From the Field
What Developers Like about TDD
Join our mailing list
CppUTest
Testimonials
Attendee Feedback - Training
Attendee Feedback - Workshop
Attendee Preparation Replies
Attendee 1st impressions of TDD
Sign in
TDD How-to: Get your Legacy C Into a Test Harness
You are getting started with TDD, but have existing code? You want to get some of your challenging C/C++ code under test? You have run into some apparent show stoppers? Don't give up! This article contains a step by step recipe to help get your code into a test harness.  It also contains a series of C/C++ code problems that get in the way of unit testing. Each problem named comes with one or more suggested solutions. Also, many of the solutions provide links to articles with more detail.
Many of the problems described arise from trying to get embedded systems code that has only been compiled with the target hardware cross-compiler, to compile off-target. These problems are not unheard of for non-embedded C/C++, so any C/C++ programmer can get some insight into getting your legacy code under test using this approach. Test problems come from dependencies, so If you can relate the C/C++ specific advice to your language, there is something here for non-C programmers as well.
To help you get started, I've created a
CppUTest Starter Kit
on github that you can use to help get started.  The started project describes how to setup your environment and has example tests, code, and mocks.
The approach the solving these problems follows the
Crash to Pass
algorithm, described in my book and in the linked article. To summarize, Crash to Pass describes a step by step approach to getting problem code under test.
Create a test file.
Build it; force a failure; force success. You are ready to go
Adjust your error output.
Your test build should be set to only report the first error. This saves on scrolling and accidentally chasing a side-effect error.
Choose the function you want to test.
You C++ programmers, choose the class to create.
Call the code to test from the test case.
Don't worry about initialization, yet.
Make the test file compile.
This can take a while an be discouraging in a crusty old code base. Getting the test to compile means adding
#include
s and adjusting the include path in the unit test build. This can be frustrating.
Fix problems one at a time;
only fix the first error that is staring you in the face. Try to take satisfaction in changing the error message.
Don't panic!
Look at the
Road Blocks
below as you discover problems you want some help with.
You know you are done
with 'make it compile' (probably temporarily) once you get a linker error.
Why start with compiling the test case instead of the production code?
It is a smaller first step.  The dependencies needed for compiling a call to the production code from the test case is a subset of the dependencies needed to compile the production code.  You may discover some show stoppers too.
Make the code link.
The first pass through this you will need to compile the source file that contains the function you are trying to test. You will likely cycle back to 'make the test file' compile. Once its compile time dependencies are satisfied, you are rewarded with more linker errors.
Stub problem dependencies or compile depended upon production code.
When stubbing, do the simplest stub that satisfies the compiler and linker
Make the dumbest fake
like
int my_problem_depedndency(int p) { return -1; }
.
Use my exploding fake generator.
Its a bash script you can find in my github
CppUTest Starter Kit
. It can create an 'exploding fake' for each unresolved external reference.
You know you are done
once the test builds and runs; you will likely see the test crash.
Track down the crash.
Why am I such a pessimist? You should have ignored initialization up to this point.  So if you choose code with dependencies a crash is a likely outcome for a C or C++ program. Do the needed initialization, again solving one crash at a time.
You know you are done
once you get the test runner to say OK.
Finally, make the test more interesting.
Add some checks to you test.  Limit the focus of the test
Copy, Paste, THINK!
As you add the next test, don't just copy, paste, tweak.  Make sure to think, extracting common helper functions with descriptive names.
You know you are done
... Left as an exercise to the reader. Congratulations if you got this far.
Tell me your story
Road Blocks -- Don't Panic
Along the way, you may run into one of more of these specific road-blocks to getting your code under test.
Problem - Non-portable Header File
The legacy code depends on a target specific header file that won’t compile off target.
Solution
Introduce a #include Test Double See
#include Test Double
. By the way, always prefer to use the real header. Only do this after discovering that using the real header would require changing it. If that file is from a third party, changing it is not really sustainable.
Problem - Header File Leads to Dependency Explosion
The legacy code depends on a header file with many outgoing problem dependencies that the code under test needs very little from.
Solution
Introduce a #include Test Double Again, prefer the real header, fake it if you must. See
#include Test Double
Problem - Non-standard Keywords
The legacy code uses non-standard keywords that won’t compile off-target
Solution
Make the non-standard keywords go away with a forced include. See
Hiding Non-standard C Keywords for Off-Target Testing
.
Problem - asm
The legacy code has
asm
instructions that won’t compile off-target
Solution - 1
Make
asm
go away using forced include
Solution - 2
Introduce an
AsmSpy
to capture the instruction stream and check it in a test case See
Spying on Embedded ‘asm’ directives
Problem - OS Dependency
The legacy code interacts with OS concurrency functions.
Solution
Create stub implementation for the OS calls. Keep the stubs very simple at first. Then evolve them to meet the needs of the test case. See three part article series:
Unit testing RTOS dependent code – RTOS Test-Double
Problem -
#pragma
The legacy code has
#pragma
instructions that won’t compile off-target
Solution
Adjust the compiler settings to ignore unknown #pragmas. For gcc use:
CFLAGS += -Wno-unknown-pragmas
Problem -
restrict
keyword won't compile with gnu g++
The legacy code uses
restrict
and won’t compile in a C++ test case
Solution
Adjust the gnu g++ compiler settings to :
CXXFLAGS += -Drestrict=__restrict__
Problem - statics are making testing difficult
You have static functions and data, that your tests can't see. If you need to directly access hidden functions and data, your code is telling you it is not modular. But you first have to add tests before you change it.
Solution - 1
Use preprocessor to make static go away. Now there are in the global namespace, but are not advertised in a header file.
Solution - 2
Create a test case and #include the c file in the test, giving full access. See
Accessing static Data and Functions in Legacy C — Part 1
.
Solution - 3
Create a test adaptor that #includes the c file. See
Accessing static Data and Functions in Legacy C — Part 2
.
Problem - Platform Dependencies
The legacy code calls library functions that are not available on the test platform.
Solution
Create a set of test stubs for the production code library. Link with that library for development system tests. Make some of the test doubles spies, mocks, etc. JIT as needed.
Problem - Hardware Dependencies
A legacy code file has a few functions that make testing difficult. They may have hardware or OS dependencies.
Solution
Extract the problem functions declarations into a separate header file. Include it from the original file. Extract the problem function implementations into a separate source file. Create a replacement source file made up of test stubs for the problem functions. Link with the replacement for test.
Problem - I need the real C function sometimes and test double other times
If you try to use the linker for test double substitution, you cannot have the original code in the same executable. You need the production code in some tests.
Solution
Create a function pointer with the same signature as the problem function. By default initialize the pointer with the problem function. Change clients to call through the function pointer. Override the function in the tests where needed.
Gotcha
Make sure code runs warning free, if the caller does not see the declaration, C will assume it is a direct function call.
Solution for Linux gcc
Use gcc linker wrapping. See option
--wrap symbol
of this
Stack Overflow
article.
Problems
Not available be universally available. It was not on Mac OSX, cygwin, or MinGW at the time of this writing.
Does not work for for public symbols referenced in the same compilation unit.
You've gotten this far, and none of these techniques helped
There is a limit to what can be done with the preprocessor and the linker.
Solution
Make careful changes to the code that enable testing or off-target compilation.
You've gotten this far, take The Legacy C Challenge
git clone and review the code from https://github.com/jwgrenning/problems-with-extended-c/releases/tag/v0.0
Make a list of the non-standard C extensions that will cause you trouble.
Name a solution to each problem
See a working solution
https://github.com/jwgrenning/problems-with-extended-c
Tweet
Send me an email about how it went for you.  Did you discover any new and interesting 'show-stoppers'?  Tweet it, or tell your friends.
Published:
April 06, 2014
Latest News
Self-Paced TDD for Embedded C Training Beta!
We have our self-paced TDD Training in beta.
more...
Conference Video - Deep Stack – Tracer Bullets from ADC to Browser
A blank page can be very intimidating, even for a Test-driven developer. Where do we start? Write a test, right? Not always.
more...
Podcast on Agile Amped
Here is a short interview with James about TDD and embedded software from the deliver:Agile conference last spring.
more...
Twitter, Facebook, Linked-in and Quora
James participated on these social media platforms.
more...
Programming Research -- Please Participate
Do you have some time to do a simple programming problem in C or C++ for my research?
more...
Clean Coders IoT Case Study
My long-time good friend (Uncle) Bob Martin and I have fun programming together firing tracer bullets for distributed water pressure measurement system.
more...
Reviews of our training
Here are a couple reviews of our TDD for Embedded C training.
more...
Loading news...
Books
James is the author of Test-Driven Development for Embedded C.
Have you read Test-Driven Development for Embedded C? Please write a review at
Amazon
or
Good Reads
.
Find out more
Resources
Papers and Presentations
CppUTest
Testimonials
Customer Feedback
Services
Coaching
Training
Workshops
You've read Test-Driven Development for Embedded C? Please write a review at
Amazon
or
Good Reads
.
Wingman Software
Our mission is to bring state of the art Agile Development and Design Techniques
to the embedded software community.  We also support non-embedded companies adopting
Agile methods to advance their technical practices in design, Test Driven Development,
Refactoring and acceptance testing.
Get in touch
Contact
form
Twitter
@jwgrenning
Email
info -at- wingman-sw.com
Address
Bonita Springs
FL 34135
USA
Phone
+1 847-630-0998
© Wingman Software 2014-2018. All rights reserved | Design:
Dave Rooney
using
ZeroFour, a template by
ajlkn
for
HTML5 UP

cpputest
/
cpputest
Public
Notifications
You must be signed in to change notification settings
Fork
516
Star
1.4k
Code
Issues
168
Pull requests
19
Discussions
Actions
Projects
0
Security
Insights
Additional navigation options
Code
Issues
Pull requests
Discussions
Actions
Projects
Security
Insights
Files
master
Breadcrumbs
cpputest
/
tests
/
CppUTest
/
CheatSheetTest.cpp
Blame
Blame
Latest commit
History
History
35 lines (28 loc) · 803 Bytes
master
Breadcrumbs
cpputest
/
tests
/
CppUTest
/
CheatSheetTest.cpp
Top
File metadata and controls
Code
Blame
35 lines (28 loc) · 803 Bytes
Raw
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
static
void
(*real_one) ();
static
void
stub
(){}
/*
in CheatSheetTest.cpp
*/
#
include
""
CppUTest/TestHarness.h
""
/*
Declare TestGroup with name CheatSheet
*/
TEST_GROUP
(CheatSheet)
{
/*
declare a setup method for the test group. Optional.
*/
void
setup
() CPPUTEST_OVERRIDE
{
/*
Set method real_one to stub. Automatically restore in teardown
*/
UT_PTR_SET
(real_one, stub);
}
/*
Declare a teardown method for the test group. Optional
*/
void
teardown
() CPPUTEST_OVERRIDE
{
}
};
/*
Do not forget semicolumn
*/
/*
Declare one test within the test group
*/
TEST
(CheatSheet, TestName)
{
/*
Check two longs are equal
*/
LONGS_EQUAL
(
1
,
1
);
/*
Check a condition
*/
CHECK
(
true
==
true
);
/*
Check a string
*/
STRCMP_EQUAL
(
""
HelloWorld
""
,
""
HelloWorld
""
);
}

Cpputest
CppUTest unit testing and mocking framework for C/C++
CppUTest
Core Manual
CppUMock Manual
Plugin Manual
Platforms stories
View on
GitHub
Download Release 3.8 as .zip
Download Release 3.8 as .tar.gz
Download Latest Passing Build .zip
Download Latest Passing Build .tar.gz
What is CppUTest.
CppUTest is a C /C++ based unit xUnit test framework for unit testing and for test-driving your code. It is written in C++ but is used in C and C++ projects and frequently used in embedded systems but it works for any C/C++ project.
CppUTest’s core design principles are:
Simple in design and simple in use.
Portable to old and new platforms.
Build with Test-driven Development for Test-driven Developers.
Setting up CppUTest
There are several ways to setup CppUTest.  One is to install via package management and the other is from source. The big difference is that from source you can use
MakefileWorker.mk
. MakefileWorker is not supported pre-packaged.  MakefileWorker does not require you to know a lot about
make
and makefiles to get started.
An easy way to get your first test case running is to use James Grenning’s
cpputest-starter-project for gcc
or
cpputest-starter-project for Visual Studio
.  James is the author of
Test-Driven Development for Embedded C
.  You’ll find instructions, your first test case, and some other example code.  James’ training resources use MakefileWorker, so you need to install from source.
Adding tests to untested C and C++ can be a big challenge.  You might find
Get your Legacy C into a Test Harness
a useful recipe and resource. The page includes links to numerous articles of real legacy C challenges.
Pre-packaged install
Linux
There is a Debian and an Ubuntu package available for CppUTest. This is by far the easiest way to install it, via:
$
apt-get
install
cpputest
MacOSX
For Mac, a Homebrew package is available too. You can install via:
$
brew
install
cpputest
From source install
You can download the latest ‘automatically released’ version:
Latest version passing the build
This version is automatically packages after a build has passed.
Alternatively, you can clone the github repository, read-only:
$
git clone https://github.com/cpputest/cpputest.git
Or clone it via ssh (which requires a github account)
$
git clone git@github.com:cpputest/cpputest.git
CppUTest can also be added to your git repo as a git submodule.
$
git submodule add https://github.com/cpputest/cpputest.git
Now that you have CppUTest sources, you can build it with your favorite build tool (CMake or autoconf).
Building with autoconf requires you to (this requires you to have installed GNU autotools, apt-get/brew install automake autoconf libtool):
$
cd
cpputest_build
$
autoreconf ..
-i
$
../configure
$
make
You can use
make install
if you want to install CppUTest system-wide
NOTE
: Building from
cpputest_build
means you will not be able to use
MakefileWorker.mk
.  To use MakefileWorker you need to build from the cpputest home directory.
Using CppUTest with MakefileWorker.mk and gcc
If you want to use CppUTest’s MakefileWorker, you cannot currently get CppUTest using the “Pre-packaged” options described above. Instead you can get CppUTest from source using the options already described.
Change to the top level directory of CppUTest (the directory containing
include/
and
src/
among other files)
$
cd
cpputest
\
$
autoreconf
.
-i
$
./configure
$
make tdd
$
export
CPPUTEST_HOME
=
$(
pwd
)
.
You will want to add **export CPPUTEST_HOME=
** somewhere like **.bashrc** or in your build script as a relative path.
Using CppUTest with Visual Studio
You can build CppUTest using cmake or in the Visual Studio IDE.
from Visual Studio IDE
Depending on your VS version double click either
CppUTest_VS201x.sln
- for VS 2010 and later
CppUTest.sln
- for pre VS 2010
Say yes to suggested conversions.  Select the menu item corresponding to run without debugging.  CppUTest should build (probably with warnings).  When the build completes the test runner runs. You should see over 1000 tests passing and no test failures. The build also produced a static library (cpputest/lib) holding CppUTest you can link your tests to.
To use CppUTest, define an environment variable
CPPUTEST_HOME
that points to the home directory of CppUTest.  You will find a working example and some more help in
cpputest-starter-project for Visual Studio
.
How to create a coverage report
You can use autoconf to create a coverage report for CppUTests own tests. If you have lcov installed, a browsable html report will be generated as well. After the steps outlined in the previous paragraph, do the following:
$
make check_coverage
This will generate a file called gcov_report.txt with the coverage report in plain text format. It will also generate an HTML file called gcov_report.txt.html. If you have lcov installed, you will be able to browse the lcov report by opening ./cpputest_build/test_coverage/index.html . The lcov report is by far the easiest way to inspect CppUTest’s own test coverage.
Alternatively, you can use CMake if that is the build tool you fancy (this requires you have install CMake, apt-get install cmake):
$
cd
cpputest_build
$
cmake ..
$
make
For Windows users, the above will work with cygwin. There are also several MS VC++ projects available.
Where to find more information
If you have any questions, check out the
Google Groups
The source is at the
main github page
You can report bugs or features at
the issues page
You can follow
CppUTest on twitter
Quick introduction (some code!)
To write your first test, all you need is a new cpp file with a TEST_GROUP and a TEST, like:
TEST_GROUP
(
FirstTestGroup
)
{
};
TEST
(
FirstTestGroup
,
FirstTest
)
{
FAIL
(
""Fail me!""
);
}
This test will fail.
You can add new tests to the test group by just writing more tests in the file, like this:
TEST
(
FirstTestGroup
,
SecondTest
)
{
STRCMP_EQUAL
(
""hello""
,
""world""
);
LONGS_EQUAL
(
1
,
2
);
CHECK
(
false
);
}
You do need to create a main where you run all the unit tests. Such a main will look like this:
int
main
(
int
ac
,
char
**
av
)
{
return
CommandLineTestRunner
::
RunAllTests
(
ac
,
av
);
}
For more information, We’d recommend
reading the manual
or, even better, check some
existing tests
such as
SimpleStringTest
or (a bit more complicated)
MemoryLeakDetectorTest
or the
mocking tests
or just check out the
Cheat Sheet
Related projects
For Eclipse users, also check:
CppUTest Eclipse Test Runner
This will allow you to run your tests JUnit style with red and green bars, and rerun arbitrary selections of tests.
Prerequisites:
CppUTest off master
Eclipse Juno, Kepler, or later
Eclipse C/C++ Unit Plugin (if not already present in your version of Eclipse; install directly from Eclipse Help -> Install New Software…).
CppUTest Eclipse Plugin Project
Authors and Contributors
CppUTest has had many contributions from its users. We can’t remember all, but we appreciate it a lot! Much of the original code was written by Michael Feathers (based on CppUnit Lite). The current main maintainers are
@jwgrenning
and
@basvodde

tcmak
/
CppUTestEclipseJunoTestRunner
Public
Notifications
You must be signed in to change notification settings
Fork
7
Star
11
CppUTest Test Runner for Eclipse Juno or above
11
stars
7
forks
Branches
Tags
Activity
Star
Notifications
You must be signed in to change notification settings
Code
Issues
6
Pull requests
0
Actions
Projects
0
Wiki
Security
Insights
Additional navigation options
Code
Issues
Pull requests
Actions
Projects
Wiki
Security
Insights
tcmak/CppUTestEclipseJunoTestRunner
master
Branches
Tags
Go to file
Code
Folders and files
Name
Name
Last commit message
Last commit date
Latest commit
History
14 Commits
org.eclipse.cdt.testsrunner.cpputest
org.eclipse.cdt.testsrunner.cpputest
README.md
README.md
View all files
Repository files navigation
README
This is the test runner plugin for CppUTest (
http://www.cpputest.org
) with Eclipse Juno CDT Test Runner. It works with Kepler and Luna as well.
HOW TO INSTALL
Create directory ""<YOUR_PATH_TO_ECLIPSE>/eclipse/dropins/CppUTest"".
In this repository, change into the directory ""org.eclipse.cdt.testrunner.cpputest"".
Copy the following artifacts from there to ""<YOUR_PATH_TO_ECLIPSE>/eclipse/dropins/CppUTest"":
bin/org/  -->  org/
META-INF/
plugin.properties
plugin.xml
You must copy ""bin/org/"" to ""org/"" and not to ""bin/org/"" !
Close Eclipse.
Start Eclipse from a command shell with the following command:
Eclipse -clean -console -consoleLog
""CppUTest Tests Runner"" should now be selectable as a test runner within Eclipse and successfully run a CppUTest test project.
About
CppUTest Test Runner for Eclipse Juno or above
Resources
Readme
Activity
Stars
11
stars
Watchers
2
watching
Forks
7
forks
Report repository
Releases
No releases published
Packages
0
No packages published
Contributors
2
Languages
Java
100.0%

basvodde
Follow
Overview
Repositories
44
Projects
0
Packages
0
Stars
13
More
Overview
Repositories
Projects
Packages
Stars
basvodde
Follow
Bas Vodde
basvodde
Follow
126
followers
·
0
following
Odd-e
Netherlands
http://blog.odd-e.com
Achievements
x2
x3
Achievements
x2
x3
Organizations
Block or Report
Block or report basvodde
Block user
Prevent this user from interacting with your repositories and sending you notifications.
Learn more about
blocking users
.
You must be logged in to block users.
Add an optional note:
Please don't include any personal information such as legal names or email addresses. Maximum 100 characters, markdown supported. This note will be visible to only you.
Block user
Report abuse
Contact GitHub support about this user’s behavior.
Learn more about
reporting abuse
.
Report abuse
Overview
Repositories
44
Projects
0
Packages
0
Stars
13
More
Overview
Repositories
Projects
Packages
Stars
Popular repositories
Loading
filezilla
filezilla
Public
Clone from https://svn.filezilla-project.org/svn/FileZilla3/trunk
C++
213
122
osaka
osaka
Public
Apple Application automation library using applescript (osascript)
Ruby
53
10
travis_github_deployer
travis_github_deployer
Public
Travis CI to github deployer
Ruby
11
3
cpputest_to_be_deleted
cpputest_to_be_deleted
Public
C++ Unit Test Framework
C++
2
1
subtitle_converter
subtitle_converter
Public
convert SRT subtitle file into different format
Ruby
2
1
cpputest.github.io
cpputest.github.io
Public
Forked from
cpputest/cpputest.github.io
CppUTest website
CSS
2
Something went wrong, please refresh the page to try again.
If the problem persists, check the
GitHub status page
or
contact support
.

Cpputest
CppUTest unit testing and mocking framework for C/C++
CppUTest
Core Manual
CppUMock Manual
Plugin Manual
Platforms stories
View on
GitHub
Download Release 3.8 as .zip
Download Release 3.8 as .tar.gz
Download Latest Passing Build .zip
Download Latest Passing Build .tar.gz
CppUTest plugins can be installed in the main and ‘extend’ the unit test framework. A plugin is a place where you can put work that needs to be done in all unit tests."
SetPointerPlugin,"MockSupportPlugin
IEEE754ExceptionsPlugin
OrderedTests
SetPointerPlugin
Description
The SetPointerPlugin provides a Pointer restore mechanism - helpful when tests overwrite a pointer that must be restored to its original value after the test.  This is especially helpful when a pointer to a function is modified for test purposes.
Example
int
main
(
int
ac
,
char
**
av
)
{
TestRegistry
*
r
=
TestRegistry
::
getCurrentRegistry
();
SetPointerPlugin
ps
(
""PointerStore""
);
r
->
installPlugin
(
&
ps
);
return
CommandLineTestRunner
::
RunAllTests
(
ac
,
av
);
}
TEST_GROUP
(
HelloWorld
)
{
static
int
output_method
(
const
char
*
output
,
...)
{
va_list
arguments
;
va_start
(
arguments
,
output
);
cpputest_snprintf
(
buffer
,
BUFFER_SIZE
,
output
,
arguments
);
va_end
(
arguments
);
return
1
;
}
void
setup
()
{
// overwrite the production function pointer witha an output method that captures
// output in a buffer.
UT_PTR_SET
(
helloWorldApiInstance
.
printHelloWorld_output
,
&
output_method
);
}
void
teardown
()
{
}
};
TEST
(
HelloWorld
,
PrintOk
)
{
printHelloWorld
();
STRCMP_EQUAL
(
""Hello World!
\n
""
,
buffer
)
}
// Hello.h
#ifndef HELLO_H_
#define HELLO_H_
extern
void
printHelloWorld
();
struct
helloWorldApi
{
int
(
*
printHelloWorld_output
)
(
const
char
*
,
...);
};
#endif
// Hello.c
#include <stdio.h>
#include ""hello.h""
// in production, print with printf.
struct
helloWorldApi
helloWorldApiInstance
=
{
&
printf
};
void
printHelloWorld
()
{
helloWorldApiInstance
.
printHelloWorld_output
(
""Hello World!
\n
""
);
}
MockSupportPlugin
MockSupportPlugin makes the work with mocks easier. It does the following work for you automatically:
checkExpectations at the end of every test (on global scope, which goes recursive over all scopes)
clear all expectations at the end of every test
install all comparators that were configured in the plugin at the beginning of every test
remove all comparators at the end of every test
Installing the MockPlugin means you’ll have to add to main something like:
#include ""CppUTest/TestRegistry.h""
#include ""CppUTestExt/MockSupportPlugin.h""
MyDummyComparator
dummyComparator
;
MockSupportPlugin
mockPlugin
;
mockPlugin
.
installComparator
(
""MyDummyType""
,
dummyComparator
);
TestRegistry
::
getCurrentRegistry
()
->
installPlugin
(
&
mockPlugin
);
This code creates a comparator for MyDummy and installs it at the plugin. This means the comparator is available for all test cases. It creates the plugin and installs it at the current test registry. After installing the plugin, you don’t have to worry too much anymore about calling checkExpectations or cleaning your MockSupport.
IEEE754ExceptionsPlugin
Description
This plugin detects floating point error conditions and fails the test, if any were found. According to the IEEE754 Floating Point Standard, floating point errors do not by default cause abnormal program termination. Rather, flags are set to indicate a problem, and the operation returns a defined value such as Infinity or Not-a-Number (NaN).
This is a list of floating point error conditions, and how they are supported by the plugin:
FE_DIVBYZERO
/* supported (v3.8) */
FE_OVERFLOW
/* supported (v3.8) */
FE_UNDERFLOW
/* supported (v3.8) */
FE_INVALID
/* supported (v3.8) */
FE_INEXACT
/* supported; disabled by default (v3.8) */
FE_DENORMAL
/* NOT supported (v3.8) */
You can turn on FE_INEXACT checking manually, although this probably won’t be very useful most of the time, since almost every floating-point operation is likely to set this flag:
IEEE754ExceptionsPlugin
::
enableInexact
();
IEEE754ExceptionsPlugin
::
disableInexact
();
Example
#include ""CppUTest/CommandLineTestRunner.h""
#include ""CppUTest/TestRegistry.h""
#include ""CppUTestExt/IEEE754ExceptionsPlugin.h""
int
main
(
int
ac
,
char
**
av
)
{
IEEE754ExceptionsPlugin
ieee754Plugin
;
TestRegistry
::
getCurrentRegistry
()
->
installPlugin
(
&
ieee754Plugin
);
return
CommandLineTestRunner
::
RunAllTests
(
ac
,
av
);
}
static
volatile
float
f
;
TEST_GROUP
(
CatchFloatingPointErrors
)
{
void
setup
()
{
IEEE754ExceptionsPlugin
::
disableInexact
();
}
};
TEST
(
CatchFloatingPointErrors
,
underflow
)
{
f
=
0.01
f
;
while
(
f
>
0.0
f
)
f
*=
f
;
CHECK
(
f
==
0.0
f
);
}
TEST
(
CatchFloatingPointErrors
,
inexact
)
{
IEEE754ExceptionsPlugin
::
enableInexact
();
f
=
10.0
f
;
DOUBLES_EQUAL
(
f
/
3.0
f
,
3.333
f
,
0.001
f
);
}
The output of these tests will be:
$
./example.exe
example.cpp:29: error: Failure
in
TEST
(
CatchFloatingPointErrors, inexact
)
src/CppUTestExt/IEEE754ExceptionsPlugin.cpp:164: error:
IEEE754_CHECK_CLEAR
(
FE_INEXACT
)
failed
.
example.cpp:22: error: Failure
in
TEST
(
CatchFloatingPointErrors, underflow
)
src/CppUTestExt/IEEE754ExceptionsPlugin.cpp:164: error:
IEEE754_CHECK_CLEAR
(
FE_UNDERFLOW
)
failed
.
Errors
(
2 failures, 2 tests, 2 ran, 12 checks, 0 ignored, 0 filtered out, 39 ms
)
$
Debugging floating point failures
When a test fails due to a floating point error, it can be challenging to find the location of the offending operation, since the plugin has no knowledge of where the flag was originally set. To aid in debugging, there is are a number of static methods you can use to set up a watch:
IEEE754ExceptionsPlugin
::
checkIeee754OverflowExceptionFlag
();
IEEE754ExceptionsPlugin
::
checkIeee754UnderflowExceptionFlag
();
IEEE754ExceptionsPlugin
::
checkIeee754InexactExceptionFlag
();
IEEE754ExceptionsPlugin
::
checkIeee754DivByZeroExceptionFlag
();
Here is an minimal example using Gdb, example.cpp:
#include ""CppUTest/TestHarness.h""
#include ""CppUTestExt/IEEE754ExceptionsPlugin.h""
static
volatile
float
f
=
1.0
;
static
volatile
IEEE754ExceptionsPlugin
plugin
;
// Make sure this is linked, so the debugger knows it
int
main
(
int
,
char
**
)
{
f
/=
0.0
f
;
// the offending statement
return
0
;
}
1) Compile the example. Your command line will look roughly like this:
$
g++
-Wextra
-Wall
-Werror
-g3
-O0
-std
=
c++11
-Iinclude
-Llib
example.cpp
-lCppUTest
-lCppUTestExt
-o
example.exe
2) Start the example in Gdb:
$
gdb ./example.exe
GNU gdb
(
GDB
)
7.6.50.20130728-cvs
(
cygwin-special
)
#...more gdb output here...
Reading symbols from /cygdrive/c/data/00_Dev/06_Faking/MiscellanousTests/example.exe...done.
(
gdb
)
3) Set a breakpoint and run the example:
(
gdb
)
break
main
Breakpoint 1 at 0x4011ab: file example.cpp, line 8.
(
gdb
)
run
Starting program: /cygdrive/c/data/00_Dev/06_Faking/MiscellanousTests/example.exe
[
New Thread 6476.0x2038]
[
New Thread 6476.0x239c]
Breakpoint 1, main
()
at example.cpp:8
8           f /
=
0.0f
;
(
gdb
)
4) Set up the watch you need:
(
gdb
)
watch IEEE754ExceptionsPlugin::checkIeee754DivByZeroExceptionFlag
()
Watchpoint 2: IEEE754ExceptionsPlugin::checkIeee754DivByZeroExceptionFlag
()
(
gdb
)
5) Stepping over the offending statement will change the value of your watch:
(
gdb
)
next
Watchpoint 2: IEEE754ExceptionsPlugin::checkIeee754DivByZeroExceptionFlag
()
Old value
=
false
New value
=
true
0x004011b5
in
main
()
at example.cpp:8
8           f /
=
0.0f
;
(
gdb
)
Of course you don’t have to use commandline Gdb to do this; you can debug your code from within your favorite IDE (Eclipse, Code::Blocks, …) following basically the same procedure.
OrderedTests
Usage
TEST_ORDERED
(
TestGroup
,
TestName
,
Level
)
{}
TEST_ORDERED_C_WRAPPER
(
TestGroup
,
TestName
,
Level
)
Order: Test are executed from lowest to highest level. Tests with same same level are executed top down.
#include ""CppUTest/TestHarness.h""
#include ""CppUTestExt/OrderedTest.h""
TEST_GROUP
(
TestOrderedTest
)
{}
TEST_ORDERED
(
TestOrdered
,
Test3
,
3
)
{
// 3. Test
}
TEST_ORDERED
(
TestOrdered
,
Test1
,
1
)
{
// 1. Test
}
TEST_ORDERED
(
TestOrdered
,
Test4
,
3
)
{
// 4. Test
}
TEST_ORDERED_C_WRAPPER
(
TestOrdered
,
Test2
,
2
)
TEST_ORDERED_C_WRAPPER
(
TestOrdered
,
Test5
,
5
)
Only the C++-wrapper changes, the C-file synatx is as usual.
#include ""CppUTest/TestHarness_c.h""
TEST_C
(
TestOrdered
,
Test2
)
{
// 2. Test
}
TEST_C
(
TestOrdered
,
Test5
)
{
// 5. Test
}

cpputest
/
cpputest
Public
Notifications
You must be signed in to change notification settings
Fork
516
Star
1.4k
Code
Issues
168
Pull requests
19
Discussions
Actions
Projects
0
Security
Insights
Additional navigation options
Code
Issues
Pull requests
Discussions
Actions
Projects
Security
Insights
Files
master
Breadcrumbs
cpputest
/
tests
/
Directory actions
More options
Directory actions
More options
Latest commit
History
History
master
Breadcrumbs
cpputest
/
tests
/
Top
Folders and files
Name
Name
Last commit message
Last commit date
parent directory
..
CppUTest
CppUTest
CppUTestExt
CppUTestExt
DummyUTestPlatform
DummyUTestPlatform
AllTests.vcproj
AllTests.vcproj
AllTests.vcxproj
AllTests.vcxproj
CMakeLists.txt
CMakeLists.txt
View all files"
